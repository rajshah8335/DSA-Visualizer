<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Topic 1: Arrays 3D Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0f172a;
        }

        /* Custom Scrollbar for the UI panel */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Overlay UI animations */
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Control Panel Glassmorphism */
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-panel-accent {
            background: rgba(59, 130, 246, 0.15);
            /* Blue tint */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .glass-panel-ai-thinking {
            background: rgba(139, 92, 246, 0.25);
            /* Purple tint */
            backdrop-filter: blur(12px);
            border: 1px solid rgba(139, 92, 246, 0.5);
            animation: pulse-purple 2s infinite;
        }

        @keyframes pulse-purple {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
            }
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-ai {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            transition: all 0.2s;
        }

        .btn-ai:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-secondary.active {
            background: rgba(59, 130, 246, 0.5);
            border-color: #3b82f6;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            transition: all 0.2s;
        }

        .btn-danger:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
        }

        canvas {
            outline: none;
        }

        /* Markdown-like simple styling for AI text */
        .ai-text strong {
            color: #a78bfa;
            font-weight: 600;
        }

        .ai-text em {
            color: #cbd5e1;
            font-style: italic;
        }

        /* --- Navbar & Modal Injected Styles --- */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 0.8rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .navbar.compact {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-link {
            color: #94a3b8;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
            font-size: 0.95rem;
        }

        .nav-link:hover,
        .nav-link.active {
            color: #3b82f6;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f8fafc;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .logo span {
            color: #3b82f6;
        }

        .nav-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        /* Dropdown */
        .dropdown {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: #0f172a;
            min-width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0.5rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .dropdown:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .dropdown-item {
            display: block;
            padding: 0.5rem 1rem;
            color: #cbd5e1;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal {
            background: #1e293b;
            width: 90%;
            max-width: 600px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: scale(0.95);
            transition: transform 0.3s;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal.active-modal {
            display: block;
        }

        /* Helper to show specific modal */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f8fafc;
        }

        .close-modal {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .close-modal:hover {
            color: #fff;
        }

        .modal-content {
            padding: 1.5rem;
            color: #cbd5e1;
            line-height: 1.6;
        }

        pre {
            background: #0f172a;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #a78bfa;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            .controls-container {
                width: 90% !important;
                left: 5% !important;
                top: 60px !important;
                max-height: 45vh !important;
                padding: 15px !important;
            }

            .navbar {
                flex-wrap: wrap;
                padding: 0.5rem;
            }

            .nav-links {
                gap: 1rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>

<body class="text-white h-screen w-screen relative select-none">

    <!-- Compact Navbar -->
    <nav class="navbar">
        <a href="index.html" class="logo">
            <i data-lucide="zap" class="w-6 h-6 text-blue-500"></i>
            <span>DSA</span>Visualizer
        </a>
        <div class="hamburger" id="nav-toggle">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <!-- Centered Tools -->
        <div class="nav-center">
            <a href="#" onclick="closeModals(); return false;" class="nav-link">3D Model</a>
            <a href="theory/theory1.html" onclick="openModal('')" class="nav-link">Theory</a>
            <a href="quiz1.html" class="nav-link">Quiz</a>
            <a href="programs.html?filter=array" class="nav-link">Program</a>
        </div>

        <div class="nav-links">
            <a href="index.html" class="nav-link">Home</a>
            <a href="topics.html" class="nav-link">Topics</a>
            <a href="#" class="nav-link">About</a>
        </div>
    </nav>

    <!-- Modals Overlay -->
    <div id="modal-overlay" class="modal-overlay" onclick="if(event.target === this) closeModals()">
        <!-- Theory -->
        <div id="modal-theory" class="modal">
            <div class="modal-header">
                <h2>Array Theory</h2><button class="close-modal" onclick="closeModals()">×</button>
            </div>
            <div class="modal-content">
                <p>An array is a linear data structure that collects elements of the same data type and stores them in
                    contiguous and adjacent memory locations.</p>
                <h3 class="text-white font-bold mt-4">Key Features:</h3>
                <ul class="list-disc pl-5 mt-2 space-y-1">
                    <li>Fixed Size: Once created, the size cannot be changed.</li>
                    <li>Random Access: Elements can be accessed directly using their index (O(1)).</li>
                    <li>Contiguous Memory: Elements are stored side-by-side.</li>
                </ul>
            </div>
        </div>
        <!-- Quiz -->
        <div id="modal-quiz" class="modal">
            <div class="modal-header">
                <h2>Array Quiz</h2><button class="close-modal" onclick="closeModals()">×</button>
            </div>
            <div class="modal-content">
                <p class="font-semibold mb-4">Q1: What is the time complexity to access an element in an array by index?
                </p>
                <div class="space-y-2">
                    <button
                        class="w-full text-left p-3 rounded bg-slate-800 hover:bg-blue-600/30 transition border border-slate-700">A.
                        O(n)</button>
                    <button
                        class="w-full text-left p-3 rounded bg-slate-800 hover:bg-blue-600/30 transition border border-slate-700">B.
                        O(log n)</button>
                    <button
                        class="w-full text-left p-3 rounded bg-slate-800 hover:bg-green-500/30 transition border border-green-500/50">C.
                        O(1) (Correct)</button>
                </div>
            </div>
        </div>
        <!-- Program -->
        <div id="modal-program" class="modal">
            <div class="modal-header">
                <h2>C++ Implementation</h2><button class="close-modal" onclick="closeModals()">×</button>
            </div>
            <div class="modal-content">
                <p>Basic implementation of an Array in C++.</p>
                <pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    cout << "First Element: " << arr[0];
    return 0;
}</pre>
            </div>
        </div>
    </div>

    <!-- Main Content Wrapper (Below Navbar) -->
    <div id="visualization-wrapper"
        class="relative w-full h-[calc(100vh-6rem)] mt-24 border-t border-slate-700/50 shadow-2xl overflow-hidden">

        <!-- 3D Canvas Container -->
        <div id="canvas-container" class="absolute inset-0 z-0 cursor-move bg-slate-900"></div>

        <!-- Main UI Overlay (Inside Wrapper) -->
        <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6">

            <!-- Header -->
            <div class="pointer-events-auto flex justify-between items-start">
                <div class="glass-panel p-4 rounded-xl shadow-2xl max-w-sm fade-in">
                    <h1
                        class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-emerald-400 mb-1">
                        <i data-lucide="box" class="inline w-6 h-6 mr-2 text-blue-400"></i>Arrays 3D
                    </h1>
                    <p class="text-gray-400 text-sm">Visualizing Data Structures & Algorithms</p>

                    <!-- Status/Log Box -->
                    <div
                        class="mt-4 p-3 bg-gray-900/80 rounded-lg border border-gray-700 min-h-[60px] flex items-center">
                        <p id="status-text" class="text-sm text-emerald-300 font-mono animate-pulse">Ready. Select a
                            mode to
                            begin.</p>
                    </div>
                </div>

                <!-- Right Side: Dimensions Display (Replaced old button) -->
                <div class="flex flex-col gap-2 pointer-events-auto max-w-xs items-end">
                    <div class="glass-panel p-3 rounded-xl fade-in delay-200">
                        <div id="dimension-display"
                            class="text-sm font-mono text-blue-300 font-bold flex items-center gap-2 px-2">
                            <i data-lucide="ruler" class="w-4 h-4"></i>
                            <span id="dimension-text">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Response Bubble (Only shows on Explain click) -->
            <div id="ai-response-container"
                class="absolute bottom-24 right-6 hidden fade-in max-w-sm w-full z-20 pointer-events-auto">
                <div id="ai-bubble"
                    class="glass-panel-accent p-4 rounded-xl relative shadow-lg border border-indigo-500/30 backdrop-blur-md">
                    <div class="flex items-center gap-2 mb-2 text-indigo-300">
                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                        <span id="ai-header" class="text-xs font-bold uppercase tracking-wider">AI Insight</span>
                    </div>
                    <div id="ai-response-text" class="text-sm text-gray-200 leading-relaxed font-light ai-text"></div>
                    <button onclick="document.getElementById('ai-response-container').classList.add('hidden')"
                        class="absolute top-2 right-2 text-gray-400 hover:text-white transition">
                        <i data-lucide="x" class="w-3 h-3"></i>
                    </button>
                </div>
            </div>

            <!-- Controls Dock -->
            <div
                class="pointer-events-auto self-center glass-panel p-2 rounded-2xl flex gap-2 items-center mb-4 overflow-x-auto max-w-full fade-in shadow-2xl relative">
                <!-- Mode Selector -->
                <select id="mode-select"
                    class="bg-gray-800 text-white text-sm rounded-lg px-3 py-2 border-none focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer hover:bg-gray-700 transition">
                    <option value="1d">1D Array (Static)</option>
                    <option value="2d">2D Matrix</option>
                </select>

                <div class="h-8 w-px bg-gray-700 mx-1"></div>

                <!-- AI Toggle Button -->
                <button id="ai-mode-btn"
                    class="btn-ai text-white font-medium py-1.5 px-3 rounded-lg text-sm flex items-center gap-2 whitespace-nowrap transition"
                    title="Use AI Command">
                    <i data-lucide="bot" class="w-4 h-4"></i>
                </button>

                <div class="h-8 w-px bg-gray-700 mx-1"></div>

                <!-- Dynamic Controls Container -->
                <div id="controls-container" class="flex gap-2 items-center">
                    <!-- Injected via JS based on mode -->
                </div>

                <!-- AI Command Input (Hidden by default) -->
                <div id="ai-command-container" class="hidden flex items-center gap-2 w-full md:w-96">
                    <input id="ai-input" type="text"
                        placeholder="Type request: 'Swap first and last' or 'Fill with random'"
                        class="bg-gray-800 text-white text-sm px-3 py-1.5 rounded-lg outline-none border border-indigo-500 focus:bg-gray-700 transition w-full placeholder-gray-500">

                    <!-- Simulate Button -->
                    <button id="ai-submit-btn" class="btn-ai text-white font-medium py-1.5 px-3 rounded-lg text-sm"
                        title="Simulate Command">
                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                    </button>

                    <!-- Explain State Button -->
                    <button id="ai-explain-btn"
                        class="btn-secondary text-white font-medium py-1.5 px-3 rounded-lg text-sm hover:bg-indigo-500/20 hover:border-indigo-400 border border-gray-600"
                        title="Explain Current State">
                        <i data-lucide="message-square" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Help Tooltip -->
        <div
            class="absolute bottom-6 right-6 z-10 glass-panel px-4 py-2 rounded-full text-xs text-gray-400 pointer-events-none fade-in">
            <i data-lucide="mouse-pointer-2" class="inline w-3 h-3 mr-1"></i> Drag to rotate • Scroll to zoom
        </div>
    </div> <!-- End Visualization Wrapper -->

    <script>
        // --- Modal Logic ---
        // --- Modal Logic ---
        function openModal(type) {
            const overlay = document.getElementById('modal-overlay');
            const modals = document.querySelectorAll('.modal');

            // Hide all first
            modals.forEach(m => m.classList.remove('active-modal'));

            const target = document.getElementById('modal-' + type);
            if (target) {
                overlay.classList.add('active');
                target.classList.add('active-modal');
            }
        }

        function closeModals() {
            document.getElementById('modal-overlay').classList.remove('active');
            document.querySelectorAll('.modal').forEach(m => {
                m.classList.remove('active-modal');
            });
        }

        // --- 1. Three.js & Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#0f172a');
        scene.fog = new THREE.Fog('#0f172a', 20, 50);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 10, 24);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Window Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0x3b82f6, 1.5);
        spotLight.position.set(-10, 15, 0);
        spotLight.angle = 0.5;
        spotLight.penumbra = 1;
        scene.add(spotLight);

        // Floor
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e293b,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(planeGeometry, planeMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(100, 50, 0x64748b, 0x334155);
        gridHelper.position.y = -1.99;
        scene.add(gridHelper);

        // --- OrbitControls Setup ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 60;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        // --- 2. Interactive Logic & State ---
        let currentMode = '1d';
        let objects = [];
        let labels = [];
        let connectors = [];
        let isAnimating = false;
        let isAIMode = false;

        // Colors
        const COLORS = {
            base: 0x3b82f6,
            empty: 0x374151,
            highlight: 0xfbbf24,
            success: 0x10b981,
            delete: 0xef4444,
            connector: 0x64748b
        };

        // Text Texture Helper
        function createTextTexture(text, bgColor = 'rgba(0,0,0,0)') {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 512, 512);

            ctx.font = 'bold 240px Inter, Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 8;
            ctx.fillText(text, 256, 256);

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // Box Factory
        function createBox(x, z, val, color = COLORS.base, transparent = false) {
            const baseSize = 1.8;
            let h = baseSize;
            let y = 0;

            const geometry = new THREE.BoxGeometry(1.8, h, 1.8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.1,
                transparent: true,
                opacity: 0.9
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // Value Label inside cube
            if (val !== null && val !== undefined) {
                const spriteMap = createTextTexture(val.toString());
                const spriteMat = new THREE.SpriteMaterial({
                    map: spriteMap,
                    depthTest: false,
                    transparent: true,
                    color: 0xffffff
                });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(0, 0, 0);
                sprite.scale.set(1.5, 1.5, 1);
                sprite.renderOrder = 1;
                cube.userData.sprite = sprite;
                cube.add(sprite);
            }

            cube.userData = { ...cube.userData, value: val, originalColor: color, baseY: y };
            return cube;
        }

        function createConnector(p1, p2) {
            const path = new THREE.LineCurve3(p1, p2);
            const geometry = new THREE.TubeGeometry(path, 1, 0.1, 8, false);
            const material = new THREE.MeshBasicMaterial({ color: COLORS.connector, transparent: true, opacity: 0.6 });
            const tube = new THREE.Mesh(geometry, material);
            return tube;
        }

        // Clean Scene
        function clearScene() {
            objects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                if (obj.userData.sprite) {
                    scene.remove(obj.userData.sprite);
                    if (obj.userData.sprite.material) obj.userData.sprite.material.dispose();
                }
            });
            objects = [];

            labels.forEach(lbl => {
                scene.remove(lbl);
                if (lbl.material && lbl.material.map) lbl.material.map.dispose();
                if (lbl.material) lbl.material.dispose();
            });
            labels = [];

            connectors.forEach(c => {
                scene.remove(c);
                if (c.geometry) c.geometry.dispose();
                if (c.material) c.material.dispose();
            });
            connectors = [];
        }

        // --- 3. Mode Implementations ---
        let arrayData = [10, 25, 4, 18, 92, 33, 7];
        let matrixData = [];
        const MATRIX_ROWS = 3;
        const MATRIX_COLS = 3;

        function initMatrixData() {
            if (matrixData.length > 0) return;
            for (let r = 0; r < MATRIX_ROWS; r++) {
                let row = [];
                for (let c = 0; c < MATRIX_COLS; c++) {
                    row.push(Math.floor(Math.random() * 90) + 10);
                }
                matrixData.push(row);
            }
        }

        const dimensionText = document.getElementById('dimension-text');

        function updateDimensionsDisplay() {
            if (currentMode === '1d') {
                dimensionText.innerText = `Size: ${arrayData.length}`;
            } else {
                dimensionText.innerText = `Matrix: ${MATRIX_ROWS}x${MATRIX_COLS}`;
            }
        }

        function render1DArray() {
            clearScene();
            updateDimensionsDisplay();

            const spacing = 2;
            const startX = -(arrayData.length * spacing) / 2 + 1;

            arrayData.forEach((val, i) => {
                const x = startX + i * spacing;
                const y = 0;

                const box = createBox(x, y, val, COLORS.base);

                // Index Label
                const idxMap = createTextTexture(i.toString());
                const idxMat = new THREE.SpriteMaterial({ map: idxMap, color: 0xffffff });
                const idxSprite = new THREE.Sprite(idxMat);
                idxSprite.position.y = -0.5 - (box.geometry.parameters.height / 2);
                idxSprite.scale.set(1, 1, 1);
                box.add(idxSprite);

                scene.add(box);
                objects.push(box);
            });

            // Draw Connectors
            for (let i = 0; i < objects.length - 1; i++) {
                const p1 = objects[i].position.clone();
                const p2 = objects[i + 1].position.clone();
                p1.y = -0.5;
                p2.y = -0.5;

                const line = createConnector(p1, p2);
                scene.add(line);
                connectors.push(line);
            }
        }

        function render2DArray() {
            clearScene();
            initMatrixData();
            updateDimensionsDisplay();

            const spacing = 2.8;
            const startX = -(MATRIX_COLS * spacing) / 2 + (spacing / 2);
            const startY = (MATRIX_ROWS * spacing) / 2 + 2;

            for (let r = 0; r < MATRIX_ROWS; r++) {
                for (let c = 0; c < MATRIX_COLS; c++) {
                    const val = matrixData[r][c];
                    const box = createBox(0, 0, val, COLORS.base);
                    box.rotation.x = Math.PI / 2;

                    const x = startX + c * spacing;
                    const y = startY - r * spacing;
                    let z = 0;

                    box.position.set(x, y, z);

                    // Add index label
                    const label = createTextTexture(`[${r},${c}]`);
                    const labelMat = new THREE.SpriteMaterial({ map: label, color: 0xffffff });
                    const labelSprite = new THREE.Sprite(labelMat);
                    labelSprite.position.set(x, y - 1.4, z + 0.91);
                    labelSprite.scale.set(0.9, 0.9, 1);

                    scene.add(labelSprite);
                    labels.push(labelSprite);
                    scene.add(box);
                    objects.push(box);
                }
            }
        }

        // --- 4. Operations & Animations ---
        function tween(obj, targetProps, duration = 500, onComplete) {
            const startProps = {};
            for (let k in targetProps) startProps[k] = obj[k];
            const startTime = performance.now();

            function update(time) {
                let elapsed = time - startTime;
                let progress = Math.min(elapsed / duration, 1);
                let ease = 1 - Math.pow(1 - progress, 3);
                for (let k in targetProps) obj[k] = startProps[k] + (targetProps[k] - startProps[k]) * ease;
                if (progress < 1) requestAnimationFrame(update);
                else if (onComplete) onComplete();
            }
            requestAnimationFrame(update);
        }

        function tweenColor(mesh, hexColor, duration = 300) {
            const initial = new THREE.Color(mesh.material.color.getHex());
            const target = new THREE.Color(hexColor);
            const startTime = performance.now();

            function update(time) {
                let progress = Math.min((time - startTime) / duration, 1);
                mesh.material.color.lerpColors(initial, target, progress);
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        function resetColors() {
            objects.forEach(obj => {
                if (obj.userData && obj.userData.originalColor) {
                    tweenColor(obj, obj.userData.originalColor);
                }
            });
        }

        // --- AI Response Logic ---
        function showAIResponse(msg) {
            const container = document.getElementById('ai-response-container');
            const text = document.getElementById('ai-response-text');
            const bubble = document.getElementById('ai-bubble');

            const formatted = msg.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text.innerHTML = formatted;
            container.classList.remove('hidden');
            bubble.classList.remove('glass-panel-ai-thinking');
            bubble.classList.add('glass-panel-accent');
            document.getElementById('ai-header').innerText = "AI Insight";
        }

        function showThinking() {
            const container = document.getElementById('ai-response-container');
            const text = document.getElementById('ai-response-text');
            const bubble = document.getElementById('ai-bubble');

            container.classList.remove('hidden');
            bubble.classList.remove('glass-panel-accent');
            bubble.classList.add('glass-panel-ai-thinking');
            document.getElementById('ai-header').innerText = "Gemini Processing...";
            text.innerText = "Analyzing your request and generating simulation steps...";
        }

        function explainCurrentState() {
            const cmd = "Explain the current state of the data structure.";
            handleGeminiCommand(cmd, true);
        }

        const aiExplainBtn = document.getElementById('ai-explain-btn');
        aiExplainBtn.addEventListener('click', explainCurrentState);

        // --- 1D Visualizations ---
        async function visualizeLinearSearch(val) {
            if (isAnimating) return;
            isAnimating = true;
            resetColors();
            updateStatus(`Searching for value: ${val}...`);

            for (let i = 0; i < arrayData.length; i++) {
                const box = objects[i];
                if (!box.geometry) continue;

                tweenColor(box, COLORS.highlight);
                updateStatus(`Checking index ${i}: Value ${arrayData[i]}`);
                await new Promise(r => setTimeout(r, 600));

                if (arrayData[i] == val) {
                    tweenColor(box, COLORS.success);
                    const originalY = box.position.y;
                    tween(box.position, { y: originalY + 1.5 }, 200, () => {
                        tween(box.position, { y: originalY }, 200);
                    });
                    updateStatus(`Found ${val} at index ${i}!`);
                    isAnimating = false;
                    return;
                } else {
                    tweenColor(box, COLORS.base);
                }
            }
            updateStatus(`Value ${val} not found.`);
            isAnimating = false;
        }

        async function visualizeInsertion(index, value) {
            if (isAnimating) return;
            if (index < 0) index = 0;
            if (index > arrayData.length) index = arrayData.length;

            isAnimating = true;
            updateStatus(`Inserting ${value} at index ${index}...`);

            const newLength = arrayData.length + 1;
            const startX = -(newLength * 2) / 2 + 1;

            const shiftPromises = [];
            for (let i = 0; i < index; i++) {
                const targetX = startX + i * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, { x: targetX }, 600, r)));
            }
            for (let i = index; i < objects.length; i++) {
                const targetX = startX + (i + 1) * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, { x: targetX }, 600, r)));
            }

            await Promise.all(shiftPromises);
            await new Promise(r => setTimeout(r, 100));

            arrayData.splice(index, 0, value);
            render1DArray();

            const newBox = objects[index];
            if (newBox) {
                newBox.scale.set(0.1, 0.1, 0.1);
                tweenColor(newBox, COLORS.success);
                tween(newBox.scale, { x: 1, y: 1, z: 1 }, 400);
                await new Promise(r => setTimeout(r, 600));
                tweenColor(newBox, COLORS.base);
            }

            updateStatus(`Inserted ${value} at index ${index}.`);
            isAnimating = false;
        }

        async function visualizeDeletion(index) {
            if (isAnimating) return;
            if (index < 0 || index >= arrayData.length) {
                updateStatus("Invalid Index");
                return;
            }
            isAnimating = true;
            updateStatus(`Deleting element at index ${index}...`);

            const targetBox = objects[index];

            tweenColor(targetBox, COLORS.delete);
            tween(targetBox.scale, { x: 0.1, y: 0.1, z: 0.1 }, 400);
            await new Promise(r => setTimeout(r, 450));

            const newLength = arrayData.length - 1;
            const startX = -(newLength * 2) / 2 + 1;

            const shiftPromises = [];
            for (let i = 0; i < index; i++) {
                const targetX = startX + i * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, { x: targetX }, 600, r)));
            }
            for (let i = index + 1; i < objects.length; i++) {
                const targetX = startX + (i - 1) * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, { x: targetX }, 600, r)));
            }

            if (shiftPromises.length > 0) await Promise.all(shiftPromises);
            await new Promise(r => setTimeout(r, 100));

            arrayData.splice(index, 1);
            render1DArray();
            updateStatus(`Deleted element at index ${index}.`);
            isAnimating = false;
        }

        // --- 2D Visualizations ---
        async function visualizeUpdate2D(row, col, value) {
            if (isAnimating) return;
            if (row < 0 || row >= MATRIX_ROWS || col < 0 || col >= MATRIX_COLS) return;

            isAnimating = true;
            updateStatus(`Updating cell [${row},${col}] to ${value}...`);

            const idx = row * MATRIX_COLS + col;
            const box = objects[idx];

            if (box) {
                tweenColor(box, COLORS.highlight);
                const originalScale = box.scale.clone();
                tween(box.scale, { x: 1.2, y: 1.2, z: 1.2 }, 300);
                await new Promise(r => setTimeout(r, 400));

                matrixData[row][col] = value;

                if (box.userData.sprite) {
                    const newMap = createTextTexture(value.toString());
                    box.userData.sprite.material.map = newMap;
                }

                tweenColor(box, COLORS.success);
                await new Promise(r => setTimeout(r, 300));
                tween(box.scale, { x: 1, y: 1, z: 1 }, 300);
                tweenColor(box, COLORS.base);
            }

            updateStatus(`Updated cell [${row},${col}].`);
            isAnimating = false;
        }

        async function visualizeSearch2D(val) {
            if (isAnimating) return;
            isAnimating = true;
            resetColors();
            updateStatus(`Searching matrix for ${val}...`);
            let found = false;

            for (let r = 0; r < MATRIX_ROWS; r++) {
                for (let c = 0; c < MATRIX_COLS; c++) {
                    const idx = r * MATRIX_COLS + c;
                    const box = objects[idx];
                    const cellVal = matrixData[r][c];

                    tweenColor(box, COLORS.highlight, 100);
                    updateStatus(`Checking [${r},${c}]...`);
                    await new Promise(r => setTimeout(r, 250));

                    if (cellVal == val) {
                        tweenColor(box, COLORS.success);
                        const isVertical = Math.abs(box.rotation.x - Math.PI / 2) < 0.1;

                        if (isVertical) {
                            tween(box.position, { z: box.position.z + 1.5 }, 200, () => {
                                tween(box.position, { z: box.position.z - 1.5 }, 200);
                            });
                        } else {
                            tween(box.position, { y: box.position.y + 1 }, 200, () => {
                                tween(box.position, { y: box.position.y - 1 }, 200);
                            });
                        }

                        found = true;
                        updateStatus(`Found ${val} at [${r},${c}]`);
                        isAnimating = false;
                        return;
                    } else {
                        tweenColor(box, COLORS.base, 100);
                    }
                }
            }

            if (!found) updateStatus(`Value ${val} not found in matrix.`);
            isAnimating = false;
        }

        // --- 5. UI & Event Handling ---
        const controlsContainer = document.getElementById('controls-container');
        const modeSelect = document.getElementById('mode-select');
        const statusText = document.getElementById('status-text');
        const aiModeBtn = document.getElementById('ai-mode-btn');
        const aiCommandContainer = document.getElementById('ai-command-container');
        const aiInput = document.getElementById('ai-input');
        const aiSubmitBtn = document.getElementById('ai-submit-btn');

        function updateStatus(msg) {
            statusText.innerText = msg;
            statusText.parentElement.classList.remove('animate-pulse');
            void statusText.parentElement.offsetWidth;
            statusText.parentElement.classList.add('animate-pulse');
        }

        function createButton(text, iconName, onClick, primary = true, isDanger = false) {
            const btn = document.createElement('button');
            let cls = primary
                ? "btn-primary text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none"
                : "bg-gray-700 hover:bg-gray-600 text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none transition";

            if (isDanger) cls = "btn-danger text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none";

            btn.className = cls;
            btn.innerHTML = `<i data-lucide="${iconName}" class="w-4 h-4"></i>`;
            btn.onclick = onClick;
            return btn;
        }

        function createInput(placeholder, width = 'w-12', value = '', rounded = 'rounded-l-lg') {
            const input = document.createElement('input');
            input.type = 'number';
            input.placeholder = placeholder;
            if (value) input.value = value;
            input.className = `bg-gray-800 text-white text-xs px-2 py-1.5 outline-none border border-gray-600 focus:bg-gray-700 transition ${width} text-center placeholder-gray-500 ${rounded}`;
            return input;
        }

        function createControlGroup(elements) {
            const wrapper = document.createElement('div');
            wrapper.className = "flex items-center shadow-lg mr-2";
            elements.forEach(el => wrapper.appendChild(el));
            return wrapper;
        }

        function updateControls() {
            controlsContainer.innerHTML = '';

            if (currentMode === '1d') {
                const searchIn = createInput('Val', 'w-12', '18');
                const searchBtn = createButton('Search', 'search', () => {
                    const val = parseInt(searchIn.value);
                    if (!isNaN(val)) visualizeLinearSearch(val);
                });
                controlsContainer.appendChild(createControlGroup([searchIn, searchBtn]));

                const insIdx = createInput('Index', 'w-16', '', 'rounded-l-lg border-r-0');
                const insVal = createInput('Value', 'w-16', '', 'rounded-none');
                const insBtn = createButton('Insert', 'plus-square', () => {
                    const i = parseInt(insIdx.value);
                    const v = parseInt(insVal.value);
                    if (isNaN(i) || isNaN(v)) { updateStatus("Enter Index & Value"); return; }
                    visualizeInsertion(i, v);
                });
                controlsContainer.appendChild(createControlGroup([insIdx, insVal, insBtn]));

                const delIdx = createInput('Index', 'w-16', '');
                const delBtn = createButton('Delete', 'trash-2', () => {
                    const i = parseInt(delIdx.value);
                    if (isNaN(i)) { updateStatus("Enter Index"); return; }
                    visualizeDeletion(i);
                }, true, true);
                controlsContainer.appendChild(createControlGroup([delIdx, delBtn]));

            } else if (currentMode === '2d') {
                const travBtn = document.createElement('button');
                travBtn.className = "btn-primary text-white font-medium py-1.5 px-4 rounded-lg text-sm flex items-center gap-2 whitespace-nowrap";
                travBtn.innerHTML = `<i data-lucide="grid" class="w-4 h-4"></i> Traverse`;
                travBtn.onclick = async () => {
                    if (isAnimating) return;
                    isAnimating = true;
                    resetColors();
                    updateStatus("Traversing 2D Array (Row-Major)...");
                    for (let i = 0; i < objects.length; i++) {
                        const box = objects[i];
                        const r = Math.floor(i / MATRIX_COLS);
                        const c = i % MATRIX_COLS;
                        const coords = `[${r}, ${c}]`;

                        tweenColor(box, COLORS.highlight, 150);
                        updateStatus(`Visiting ${coords}`);
                        await new Promise(r => setTimeout(r, 400));
                        tweenColor(box, COLORS.success, 150);
                    }
                    updateStatus("Traversal Complete.");
                    isAnimating = false;
                };
                controlsContainer.appendChild(travBtn);
            }
            lucide.createIcons();
        }

        // --- GEMINI AI INTEGRATION ---
        async function callGeminiAPI(userPrompt) {
            const stateData = currentMode === '1d' ? arrayData : matrixData;

            const systemPrompt = `You are an AI assistant for a 3D Array Visualizer. Analyze the user request and return a JSON response with:
1. Explanation of what will happen
2. List of commands to execute

Current State:
- Mode: ${currentMode}
- Data: ${JSON.stringify(stateData)}
- Data Type: ${currentMode === '1d' ? '1D Array' : '2D Matrix'}

Available Commands for 1D:
- insert(index, value): Insert value at index
- delete(index): Delete element at index
- search(value): Search for value
- reset(): Reset to default array
- fill(count): Fill with random values
- clear(): Clear array

Available Commands for 2D:
- update2D(row, col, value): Update matrix cell
- search2D(value): Search matrix
- reset(): Reset matrix
- traverse(): Traverse matrix

IMPORTANT: Return ONLY JSON in this format:
{
    "explanation": "Brief explanation here",
    "commands": [
        {"cmd": "commandName", "args": [arg1, arg2, ...]}
    ]
}`;

            try {
                // Modified to work without backend - will use fallback
                const response = await fetch("http://localhost:5000/api/gemini", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        userPrompt,
                        systemPrompt
                    })
                });

                if (!response.ok) {
                    throw new Error("Backend not available - using fallback");
                }

                const data = await response.json();
                console.log("Backend response:", data);

                // Parse response - handle different formats
                let parsedData;
                if (typeof data === 'string') {
                    parsedData = JSON.parse(data);
                } else if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const text = data.candidates[0].content.parts[0].text;
                    parsedData = JSON.parse(text);
                } else {
                    parsedData = data;
                }

                return parsedData;

            } catch (error) {
                console.log("Using fallback AI response:", error);
                // Fallback responses for common commands
                return getFallbackResponse(userPrompt, stateData);
            }
        }

        function getFallbackResponse(userPrompt, stateData) {
            const prompt = userPrompt.toLowerCase();

            if (currentMode === '1d') {
                if (prompt.includes('search') || prompt.includes('find')) {
                    const searchVal = extractNumber(prompt) || 18;
                    return {
                        explanation: `**Search Operation**: Searching for value ${searchVal} in the array using linear search algorithm.`,
                        commands: [{ "cmd": "search", "args": [searchVal] }]
                    };
                } else if (prompt.includes('insert') || prompt.includes('add')) {
                    const num = extractNumber(prompt) || 50;
                    const index = extractPosition(prompt) || Math.floor(stateData.length / 2);
                    return {
                        explanation: `**Insert Operation**: Inserting value ${num} at index ${index}. This shifts elements to the right.`,
                        commands: [{ "cmd": "insert", "args": [index, num] }]
                    };
                } else if (prompt.includes('delete') || prompt.includes('remove')) {
                    const index = extractPosition(prompt) || 0;
                    return {
                        explanation: `**Delete Operation**: Removing element at index ${index}. This shifts elements to the left.`,
                        commands: [{ "cmd": "delete", "args": [index] }]
                    };
                } else if (prompt.includes('reset') || prompt.includes('default')) {
                    return {
                        explanation: `**Reset Operation**: Restoring array to default values [10, 25, 4, 18, 92, 33, 7].`,
                        commands: [{ "cmd": "reset", "args": [] }]
                    };
                } else if (prompt.includes('fill') || prompt.includes('random')) {
                    const count = extractNumber(prompt) || 7;
                    return {
                        explanation: `**Random Fill**: Generating ${count} random numbers between 1-99.`,
                        commands: [{ "cmd": "fill", "args": [count] }]
                    };
                }
            } else if (currentMode === '2d') {
                if (prompt.includes('search') || prompt.includes('find')) {
                    const searchVal = extractNumber(prompt) || 42;
                    return {
                        explanation: `**Matrix Search**: Searching for value ${searchVal} in the 3x3 matrix using row-major traversal.`,
                        commands: [{ "cmd": "search2D", "args": [searchVal] }]
                    };
                } else if (prompt.includes('update') || prompt.includes('change')) {
                    const numbers = extractAllNumbers(prompt);
                    const row = numbers[0] || 1;
                    const col = numbers[1] || 1;
                    const value = numbers[2] || 99;
                    return {
                        explanation: `**Matrix Update**: Updating cell [${row},${col}] to value ${value}.`,
                        commands: [{ "cmd": "update2D", "args": [row, col, value] }]
                    };
                } else if (prompt.includes('traverse') || prompt.includes('visit')) {
                    return {
                        explanation: `**Matrix Traversal**: Visiting all cells in row-major order (left to right, top to bottom).`,
                        commands: [{ "cmd": "traverse", "args": [] }]
                    };
                } else if (prompt.includes('reset') || prompt.includes('default')) {
                    return {
                        explanation: `**Matrix Reset**: Regenerating matrix with random values.`,
                        commands: [{ "cmd": "reset", "args": [] }]
                    };
                }
            }

            // Default explanation for state
            return {
                explanation: `**Current State**: Mode: ${currentMode}, Data: ${JSON.stringify(stateData)}. The visualizer is ready for operations.`,
                commands: []
            };
        }

        function extractNumber(text) {
            const match = text.match(/\d+/);
            return match ? parseInt(match[0]) : null;
        }

        function extractPosition(text) {
            const match = text.match(/index\s*(\d+)|position\s*(\d+)|at\s*(\d+)/i);
            return match ? parseInt(match[1] || match[2] || match[3]) : null;
        }

        function extractAllNumbers(text) {
            const matches = text.match(/\d+/g);
            return matches ? matches.map(Number) : [];
        }

        async function executeAICommands(commandList) {
            if (!commandList || !Array.isArray(commandList)) {
                console.error("Invalid command list:", commandList);
                return;
            }

            for (const item of commandList) {
                const { cmd, args } = item;
                console.log("Executing:", cmd, "with args:", args);

                // Wait for animation to complete
                while (isAnimating) {
                    await new Promise(r => setTimeout(r, 100));
                }

                // Validate command for current mode
                if (currentMode === '2d' && ['insert', 'delete', 'search'].includes(cmd)) {
                    updateStatus(`Command '${cmd}' not available in 2D mode.`);
                    continue;
                }
                if (currentMode === '1d' && ['update2D', 'search2D'].includes(cmd)) {
                    updateStatus(`Command '${cmd}' not available in 1D mode.`);
                    continue;
                }

                try {
                    switch (cmd) {
                        case 'insert':
                            await visualizeInsertion(args[0], args[1]);
                            break;
                        case 'delete':
                            await visualizeDeletion(args[0]);
                            break;
                        case 'search':
                            await visualizeLinearSearch(args[0]);
                            break;
                        case 'update2D':
                            await visualizeUpdate2D(args[0], args[1], args[2]);
                            break;
                        case 'search2D':
                            await visualizeSearch2D(args[0]);
                            break;
                        case 'setMode':
                            modeSelect.value = args[0];
                            modeSelect.dispatchEvent(new Event('change'));
                            await new Promise(r => setTimeout(r, 500));
                            break;
                        case 'clear':
                            if (currentMode === '1d') {
                                arrayData = [];
                                render1DArray();
                                updateStatus("Cleared Array");
                            }
                            break;
                        case 'reset':
                            if (currentMode === '1d') {
                                arrayData = [10, 25, 4, 18, 92, 33, 7];
                                render1DArray();
                            } else {
                                matrixData = [];
                                render2DArray();
                            }
                            updateStatus("Reset Data");
                            break;
                        case 'fill':
                            if (currentMode === '1d') {
                                const count = Math.min(args[0] || 5, 15);
                                arrayData = Array.from({ length: count }, () => Math.floor(Math.random() * 99) + 1);
                                render1DArray();
                                updateStatus(`Generated ${count} random numbers`);
                            }
                            break;
                        case 'traverse':
                            // For 2D traversal
                            if (currentMode === '2d') {
                                isAnimating = true;
                                resetColors();
                                updateStatus("Traversing 2D Array...");
                                for (let i = 0; i < objects.length; i++) {
                                    const box = objects[i];
                                    tweenColor(box, COLORS.highlight, 150);
                                    await new Promise(r => setTimeout(r, 400));
                                    tweenColor(box, COLORS.success, 150);
                                }
                                updateStatus("Traversal Complete.");
                                isAnimating = false;
                            }
                            break;
                        default:
                            console.warn("Unknown command:", cmd);
                    }
                } catch (error) {
                    console.error("Error executing command:", cmd, error);
                    updateStatus(`Error executing: ${cmd}`);
                }

                await new Promise(r => setTimeout(r, 500));
            }
        }

        async function handleGeminiCommand(forcedCmd = null, showBubble = false) {
            const inputVal = forcedCmd || aiInput.value.trim();
            if (!inputVal) return;

            if (!forcedCmd) aiInput.value = '';

            const bubbleContainer = document.getElementById('ai-response-container');
            if (showBubble) {
                showThinking();
            } else {
                bubbleContainer.classList.add('hidden');
                updateStatus("AI Processing...");
            }

            const aiResult = await callGeminiAPI(inputVal);

            if (!aiResult) {
                updateStatus("AI response error");
                return;
            }

            if (showBubble) {
                showAIResponse(aiResult.explanation || "No explanation provided");
            } else {
                const cleanText = (aiResult.explanation || "").replace(/\*\*/g, '').replace(/\*/g, '');
                updateStatus(cleanText.substring(0, 100) + "...");
            }

            if (aiResult.commands && aiResult.commands.length > 0) {
                if (showBubble) updateStatus("AI executing simulation steps...");
                await executeAICommands(aiResult.commands);
                updateStatus("AI Simulation Complete");
            }
        }

        // Event Listeners
        aiSubmitBtn.addEventListener('click', () => handleGeminiCommand(null, false));
        aiInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleGeminiCommand(null, false);
        });

        // Toggle AI Mode UI
        aiModeBtn.addEventListener('click', () => {
            isAIMode = !isAIMode;

            if (isAIMode) {
                controlsContainer.classList.add('hidden');
                aiCommandContainer.classList.remove('hidden');
                aiCommandContainer.classList.add('flex');

                aiCommandContainer.classList.remove('fade-in');
                void aiCommandContainer.offsetWidth;
                aiCommandContainer.classList.add('fade-in');

                aiModeBtn.innerHTML = '<i data-lucide="x" class="w-4 h-4"></i>';
                aiInput.focus();
                updateStatus("AI Command Mode Active");
            } else {
                aiCommandContainer.classList.add('hidden');
                aiCommandContainer.classList.remove('flex');
                controlsContainer.classList.remove('hidden');

                controlsContainer.classList.remove('fade-in');
                void controlsContainer.offsetWidth;
                controlsContainer.classList.add('fade-in');

                aiModeBtn.innerHTML = '<i data-lucide="bot" class="w-4 h-4"></i>';
                updateStatus("Manual Control Mode");
            }
            lucide.createIcons();
        });

        function rerender() {
            switch (currentMode) {
                case '1d': render1DArray(); break;
                case '2d': render2DArray(); break;
            }
        }

        modeSelect.addEventListener('change', (e) => {
            currentMode = e.target.value;
            if (currentMode === '1d' && arrayData.length === 0) {
                arrayData = [10, 25, 4, 18, 92, 33, 7];
            }

            updateStatus(`${currentMode.toUpperCase()} mode loaded.`);
            rerender();
            updateControls();
        });

        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            if (container) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                rerender();
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        render1DArray();
        updateControls();
        animate();
        lucide.createIcons();

        // Mobile Nav Toggle
        const navToggle = document.getElementById('nav-toggle');
        const navLinks = document.querySelector('.nav-links');
        if (navToggle && navLinks) {
            navToggle.addEventListener('click', () => {
                navLinks.classList.toggle('active');
                navToggle.classList.toggle('active');
            });
        }

        // Navbar Attachment Animation
        setTimeout(() => {
            const navbar = document.querySelector('.navbar');
            if (navbar) navbar.classList.add('compact');
        }, 100);
    </script>
</body>

</html>