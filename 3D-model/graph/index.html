<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Graph Data Structure Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111;
            color: white;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        h1 {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #4db8ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }
        input, select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            box-sizing: border-box; /* Fix padding expanding width */
            margin-bottom: 5px;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #2b6cb0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            margin-top: 5px;
        }
        button:hover {
            background: #3182ce;
        }
        button.secondary {
            background: #4a5568;
        }
        button.secondary:hover {
            background: #2d3748;
        }
        button.danger {
            background: #c53030;
        }
        button.danger:hover {
            background: #9b2c2c;
        }
        #status {
            margin-top: 15px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            font-size: 12px;
            color: #ccc;
            min-height: 20px;
            border-left: 3px solid #4db8ff;
        }
        .legend {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            font-size: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Graph Operations</h1>
        
        <div class="control-group">
            <label>Add Node</label>
            <div style="display: flex; gap: 5px;">
                <input type="text" id="node-label" placeholder="Label (e.g. A)">
                <button onclick="addNodeFromUI()" style="margin-top:0; width: 40%;">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Add Edge (Connect Nodes)</label>
            <div style="display: flex; gap: 5px;">
                <select id="source-select"><option value="">From...</option></select>
                <select id="target-select"><option value="">To...</option></select>
            </div>
            <button class="secondary" onclick="addEdgeFromUI()">Connect</button>
        </div>

        <div class="control-group">
            <label>Algorithms</label>
            <div style="display: flex; gap: 5px;">
                <select id="start-node-select"><option value="">Start Node...</option></select>
                <button onclick="runBFS()" style="margin-top:0;">Run BFS</button>
            </div>
        </div>

        <div class="control-group">
            <button class="danger" onclick="resetGraph()">Reset Graph</button>
        </div>

        <div id="status">Ready.</div>

        <div class="legend">
            <div class="legend-item"><div class="dot" style="background:#4db8ff"></div>Normal</div>
            <div class="legend-item"><div class="dot" style="background:#ffff00"></div>Visiting</div>
            <div class="legend-item"><div class="dot" style="background:#00ff00"></div>Visited</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- 1. Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        const spotLight = new THREE.PointLight(0x4db8ff, 0.5);
        spotLight.position.set(-10, 10, -10);
        scene.add(spotLight);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        gridHelper.position.y = -10;
        scene.add(gridHelper);

        // --- 2. Graph Data Structure & Visuals ---

        const NODES = []; // Array of visual node objects
        const EDGES = []; // Array of visual edge objects
        const ADJ_LIST = {}; // Logical graph: { id: [neighbor_ids] }

        // Geometry Cache
        const nodeGeometry = new THREE.SphereGeometry(1, 32, 32);
        const nodeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4db8ff, 
            roughness: 0.3, 
            metalness: 0.2 
        });
        const visitedMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x004400 });
        const visitingMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x666600 });
        
        // --- Helper: Create Text Sprite for Labels ---
        function createLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            context.font = "Bold 100px Arial";
            context.fillStyle = "rgba(255,255,255,1)";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillText(text, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 4, 1);
            return sprite;
        }

        class GraphNode {
            constructor(id) {
                this.id = id;
                this.neighbors = [];
                
                // Physics properties
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.force = new THREE.Vector3(0, 0, 0);

                // Visual mesh
                this.mesh = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
                this.mesh.castShadow = true;
                
                // Random initial position within a radius
                const r = 10;
                this.mesh.position.set(
                    (Math.random() - 0.5) * r, 
                    (Math.random() - 0.5) * r, 
                    (Math.random() - 0.5) * r
                );

                // Label
                this.sprite = createLabel(id);
                this.mesh.add(this.sprite);
                this.sprite.position.y = 1.5; // Float above node

                scene.add(this.mesh);
                NODES.push(this);
                
                // Update Select Dropdowns
                updateSelects();
            }

            setColor(type) {
                if (type === 'visited') this.mesh.material = visitedMaterial.clone();
                else if (type === 'visiting') this.mesh.material = visitingMaterial.clone();
                else this.mesh.material = nodeMaterial.clone();
            }
        }

        class GraphEdge {
            constructor(sourceNode, targetNode) {
                this.source = sourceNode;
                this.target = targetNode;

                // Visual Edge: Cylinder for better visibility (Replaces Line)
                // RadiusTop, RadiusBottom, Height, Segments
                const geometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    roughness: 0.4, 
                    metalness: 0.6 
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                scene.add(this.mesh);
                EDGES.push(this);
            }

            updatePosition() {
                const start = this.source.mesh.position;
                const end = this.target.mesh.position;
                const distance = start.distanceTo(end);

                // 1. Move to Midpoint
                this.mesh.position.copy(start).lerp(end, 0.5);
                
                // 2. Orient to look at target
                this.mesh.lookAt(end);
                // Rotate 90deg on X to align Cylinder's Y-axis with the LookAt Z-vector
                this.mesh.rotateX(Math.PI / 2); 

                // 3. Scale height to match distance
                this.mesh.scale.set(1, distance, 1);
            }
        }

        // --- 3. Physics Simulation (Force Directed) ---
        // Keeps the graph looking nice in 3D
        function updatePhysics() {
            const REPULSION = 10;
            const SPRING_LENGTH = 8;
            const SPRING_STRENGTH = 0.05;
            const DAMPING = 0.90;
            const CENTER_GRAVITY = 0.01;

            // 1. Reset Forces
            NODES.forEach(node => {
                node.force.set(0, 0, 0);
                
                // Weak gravity to center
                node.force.add(node.mesh.position.clone().multiplyScalar(-CENTER_GRAVITY));
            });

            // 2. Repulsion (Coulomb's Law-ish)
            for (let i = 0; i < NODES.length; i++) {
                for (let j = i + 1; j < NODES.length; j++) {
                    const n1 = NODES[i];
                    const n2 = NODES[j];
                    
                    const diff = new THREE.Vector3().subVectors(n1.mesh.position, n2.mesh.position);
                    let dist = diff.length();
                    if (dist === 0) dist = 0.1; // Prevent div by zero

                    const forceMagnitude = REPULSION / (dist * dist);
                    const forceDir = diff.normalize().multiplyScalar(forceMagnitude);

                    n1.force.add(forceDir);
                    n2.force.sub(forceDir);
                }
            }

            // 3. Attraction (Springs) along Edges
            EDGES.forEach(edge => {
                const n1 = edge.source;
                const n2 = edge.target;

                const diff = new THREE.Vector3().subVectors(n2.mesh.position, n1.mesh.position);
                const dist = diff.length();
                
                const stretch = dist - SPRING_LENGTH;
                const springForce = diff.normalize().multiplyScalar(stretch * SPRING_STRENGTH);

                n1.force.add(springForce);
                n2.force.sub(springForce);
            });

            // 4. Apply Velocity & Position
            NODES.forEach(node => {
                node.velocity.add(node.force);
                node.velocity.multiplyScalar(DAMPING); // Friction
                node.mesh.position.add(node.velocity);
            });

            // 5. Update Visual Edges
            EDGES.forEach(edge => edge.updatePosition());
        }


        // --- 4. Logic & Interaction ---

        function updateSelects() {
            const selects = ['source-select', 'target-select', 'start-node-select'];
            selects.forEach(id => {
                const select = document.getElementById(id);
                // Keep the first option
                const first = select.options[0];
                select.innerHTML = '';
                select.appendChild(first);
                
                NODES.forEach(node => {
                    const opt = document.createElement('option');
                    opt.value = node.id;
                    opt.innerText = node.id;
                    select.appendChild(opt);
                });
            });
        }

        function getNode(id) {
            return NODES.find(n => n.id === id);
        }

        function log(msg) {
            const el = document.getElementById('status');
            el.innerHTML = msg;
            // Clear message after 3 seconds
            // setTimeout(() => el.innerHTML = "Ready.", 3000);
        }

        function addNodeFromUI() {
            const input = document.getElementById('node-label');
            let id = input.value.trim();
            if (!id) id = "N" + (NODES.length + 1);
            
            if (getNode(id)) {
                log(`Error: Node ${id} already exists.`);
                return;
            }

            new GraphNode(id);
            ADJ_LIST[id] = [];
            input.value = "";
            log(`Added Node: ${id}`);
        }

        function addEdgeFromUI() {
            const sVal = document.getElementById('source-select').value;
            const tVal = document.getElementById('target-select').value;

            if (!sVal || !tVal) {
                log("Please select both source and target nodes.");
                return;
            }
            if (sVal === tVal) {
                log("Cannot connect a node to itself (Simple Graph).");
                return;
            }

            // Check if edge exists
            if (ADJ_LIST[sVal].includes(tVal)) {
                log("Edge already exists.");
                return;
            }

            // Logic Update (Undirected)
            ADJ_LIST[sVal].push(tVal);
            ADJ_LIST[tVal].push(sVal);

            // Visual Update
            const n1 = getNode(sVal);
            const n2 = getNode(tVal);
            new GraphEdge(n1, n2);

            log(`Added Edge: ${sVal} - ${tVal}`);
        }

        async function runBFS() {
            const startId = document.getElementById('start-node-select').value;
            if (!startId) {
                log("Select a start node for BFS.");
                return;
            }

            log(`Starting BFS from ${startId}...`);
            
            // Reset colors
            NODES.forEach(n => n.setColor('normal'));

            const queue = [startId];
            const visited = new Set();
            visited.add(startId);

            while (queue.length > 0) {
                const currentId = queue.shift();
                const currentNode = getNode(currentId);

                // Visual: Currently Visiting
                currentNode.setColor('visiting');
                log(`Visiting: ${currentId}`);
                
                // Wait for visual effect
                await new Promise(r => setTimeout(r, 800));

                // Mark as processed
                currentNode.setColor('visited');

                const neighbors = ADJ_LIST[currentId] || [];
                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        visited.add(neighborId);
                        queue.push(neighborId);
                        
                        // Visual hint that we found a neighbor
                        const neighborNode = getNode(neighborId);
                        // Optional: Flash neighbor?
                    }
                }
            }
            log("BFS Traversal Complete.");
        }

        function resetGraph() {
            // Remove meshes
            NODES.forEach(n => scene.remove(n.mesh));
            EDGES.forEach(e => scene.remove(e.mesh));
            
            // Clear arrays
            NODES.length = 0;
            EDGES.length = 0;
            for (let key in ADJ_LIST) delete ADJ_LIST[key];

            updateSelects();
            log("Graph reset.");
            
            // Add initial default graph
            initDefaultGraph();
        }

        function initDefaultGraph() {
            const ids = ['A', 'B', 'C', 'D', 'E'];
            ids.forEach(id => {
                new GraphNode(id);
                ADJ_LIST[id] = [];
            });

            const edges = [['A','B'], ['A','C'], ['B','D'], ['C','D'], ['D','E']];
            edges.forEach(pair => {
                const [s, t] = pair;
                ADJ_LIST[s].push(t);
                ADJ_LIST[t].push(s);
                new GraphEdge(getNode(s), getNode(t));
            });
            log("Initialized default graph.");
        }

        // --- 5. Main Loop ---

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            controls.update();
            renderer.render(scene, camera);
        }

        // Init
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initDefaultGraph();
        animate();

    </script>
</body>
</html>
