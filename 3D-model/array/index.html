<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Topic 1: Arrays 3D Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; overflow: hidden; background-color: #0f172a; }
        
        /* Custom Scrollbar for the UI panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        
        /* Overlay UI animations */
        .fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Control Panel Glassmorphism */
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-panel-accent {
            background: rgba(59, 130, 246, 0.15); /* Blue tint */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .glass-panel-ai-thinking {
            background: rgba(139, 92, 246, 0.25); /* Purple tint */
            backdrop-filter: blur(12px);
            border: 1px solid rgba(139, 92, 246, 0.5);
            animation: pulse-purple 2s infinite;
        }

        @keyframes pulse-purple {
            0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.2s;
        }
        .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4); }
        .btn-primary:active { transform: translateY(0); }

        .btn-ai {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            transition: all 0.2s;
        }
        .btn-ai:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4); }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
        }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.2); }
        .btn-secondary.active { background: rgba(59, 130, 246, 0.5); border-color: #3b82f6; }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            transition: all 0.2s;
        }
        .btn-danger:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4); }

        canvas { outline: none; }
        
        /* Markdown-like simple styling for AI text */
        .ai-text strong { color: #a78bfa; font-weight: 600; }
        .ai-text em { color: #cbd5e1; font-style: italic; }
    </style>
</head>
<body class="text-white h-screen w-screen relative select-none">

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0 cursor-move"></div>

    <!-- Main UI Overlay -->
    <div class="absolute top-0 left-0 h-full w-full pointer-events-none z-10 flex flex-col justify-between p-4 md:p-6">
        
        <!-- Header -->
        <div class="pointer-events-auto flex justify-between items-start">
            <div class="glass-panel p-4 rounded-xl shadow-2xl max-w-sm fade-in">
                <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-emerald-400 mb-1">
                    <i data-lucide="box" class="inline w-6 h-6 mr-2 text-blue-400"></i>Arrays 3D
                </h1>
                <p class="text-gray-400 text-sm">Visualizing Data Structures & Algorithms</p>
                
                <!-- Status/Log Box -->
                <div class="mt-4 p-3 bg-gray-900/80 rounded-lg border border-gray-700 min-h-[60px] flex items-center">
                    <p id="status-text" class="text-sm text-emerald-300 font-mono animate-pulse">Ready. Select a mode to begin.</p>
                </div>
            </div>

            <!-- Right Side: Dimensions Display (Replaced old button) -->
            <div class="flex flex-col gap-2 pointer-events-auto max-w-xs items-end">
                <div class="glass-panel p-3 rounded-xl fade-in delay-200">
                    <div id="dimension-display" class="text-sm font-mono text-blue-300 font-bold flex items-center gap-2 px-2">
                        <i data-lucide="ruler" class="w-4 h-4"></i>
                        <span id="dimension-text">Loading...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI Response Bubble (Only shows on Explain click) -->
        <div id="ai-response-container" class="absolute bottom-24 right-6 hidden fade-in max-w-sm w-full z-20 pointer-events-auto">
            <div id="ai-bubble" class="glass-panel-accent p-4 rounded-xl relative shadow-lg border border-indigo-500/30 backdrop-blur-md">
                <div class="flex items-center gap-2 mb-2 text-indigo-300">
                     <i data-lucide="sparkles" class="w-4 h-4"></i>
                     <span id="ai-header" class="text-xs font-bold uppercase tracking-wider">AI Insight</span>
                </div>
                <div id="ai-response-text" class="text-sm text-gray-200 leading-relaxed font-light ai-text"></div>
                <button onclick="document.getElementById('ai-response-container').classList.add('hidden')" class="absolute top-2 right-2 text-gray-400 hover:text-white transition">
                    <i data-lucide="x" class="w-3 h-3"></i>
                </button>
            </div>
        </div>

        <!-- Controls Dock -->
        <div class="pointer-events-auto self-center glass-panel p-2 rounded-2xl flex gap-2 items-center mb-4 overflow-x-auto max-w-full fade-in shadow-2xl relative">
            <!-- Mode Selector -->
            <select id="mode-select" class="bg-gray-800 text-white text-sm rounded-lg px-3 py-2 border-none focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer hover:bg-gray-700 transition">
                <option value="1d">1D Array (Static)</option>
                <option value="2d">2D Matrix</option>
            </select>

            <div class="h-8 w-px bg-gray-700 mx-1"></div>

            <!-- AI Toggle Button -->
            <button id="ai-mode-btn" class="btn-ai text-white font-medium py-1.5 px-3 rounded-lg text-sm flex items-center gap-2 whitespace-nowrap transition" title="Use AI Command">
                <i data-lucide="bot" class="w-4 h-4"></i>
            </button>

            <div class="h-8 w-px bg-gray-700 mx-1"></div>

            <!-- Dynamic Controls Container -->
            <div id="controls-container" class="flex gap-2 items-center">
                <!-- Injected via JS based on mode -->
            </div>

            <!-- AI Command Input (Hidden by default) -->
            <div id="ai-command-container" class="hidden flex items-center gap-2 w-full md:w-96">
                <input id="ai-input" type="text" placeholder="Type request: 'Swap first and last' or 'Fill with random'" 
                    class="bg-gray-800 text-white text-sm px-3 py-1.5 rounded-lg outline-none border border-indigo-500 focus:bg-gray-700 transition w-full placeholder-gray-500">
                
                <!-- Simulate Button -->
                <button id="ai-submit-btn" class="btn-ai text-white font-medium py-1.5 px-3 rounded-lg text-sm" title="Simulate Command">
                    <i data-lucide="sparkles" class="w-4 h-4"></i>
                </button>

                <!-- Explain State Button -->
                <button id="ai-explain-btn" class="btn-secondary text-white font-medium py-1.5 px-3 rounded-lg text-sm hover:bg-indigo-500/20 hover:border-indigo-400 border border-gray-600" title="Explain Current State">
                    <i data-lucide="message-square" class="w-4 h-4"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Help Tooltip -->
    <div class="absolute bottom-6 right-6 z-10 glass-panel px-4 py-2 rounded-full text-xs text-gray-400 pointer-events-none fade-in">
        <i data-lucide="mouse-pointer-2" class="inline w-3 h-3 mr-1"></i> Drag to rotate â€¢ Scroll to zoom
    </div>

    <script>
        // --- 1. Three.js & Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#0f172a'); // Dark slate background
        scene.fog = new THREE.Fog('#0f172a', 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 24); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0x3b82f6, 1.5);
        spotLight.position.set(-10, 15, 0);
        spotLight.angle = 0.5;
        spotLight.penumbra = 1;
        scene.add(spotLight);

        // Floor
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1e293b, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(planeGeometry, planeMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(100, 50, 0x64748b, 0x334155);
        gridHelper.position.y = -1.99; 
        scene.add(gridHelper);

        // --- OrbitControls Setup ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 60;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        // --- 2. Interactive Logic & State ---
        let currentMode = '1d';
        let objects = []; 
        let labels = []; // Track separate labels (like 2D indices)
        let connectors = []; 
        let isAnimating = false;
        let isAIMode = false;
        
        // Colors
        const COLORS = {
            base: 0x3b82f6,   // Blue
            empty: 0x374151,  // Dark Gray
            highlight: 0xfbbf24, // Amber
            success: 0x10b981,   // Emerald
            delete: 0xef4444,    // Red
            connector: 0x64748b  // Slate line
        };

        // Text Texture Helper
        function createTextTexture(text, bgColor = 'rgba(0,0,0,0)') {
            // Increased resolution for sharper text
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            // Background is transparent
            ctx.clearRect(0,0,512,512);
            
            ctx.font = 'bold 240px Inter, Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add slight shadow for readability
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 8;
            
            ctx.fillText(text, 256, 256);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // Box Factory
        function createBox(x, z, val, color = COLORS.base, transparent = false) {
            // Determine Height
            const baseSize = 1.8;
            let h = baseSize;
            let y = 0;
            
            // Standard Cube Only (No variable height bar graph logic)

            const geometry = new THREE.BoxGeometry(1.8, h, 1.8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.1,
                transparent: true,
                opacity: 0.9 // Slight transparency for the "x-ray" text look
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // Value Label (Now INSIDE the cube)
            if (val !== null && val !== undefined) {
                const spriteMap = createTextTexture(val.toString());
                const spriteMat = new THREE.SpriteMaterial({ 
                    map: spriteMap,
                    depthTest: false, // Critical: Allows text to be seen 'through' the cube
                    transparent: true,
                    color: 0xffffff // Ensure bright white
                });
                const sprite = new THREE.Sprite(spriteMat);
                
                // Position at center of cube
                sprite.position.set(0, 0, 0); 
                // Scale sprite to fit inside box
                sprite.scale.set(1.5, 1.5, 1);
                
                // Set renderOrder higher so it draws on top of the transparency
                sprite.renderOrder = 1;
                
                cube.userData.sprite = sprite; // Save ref
                cube.add(sprite);
            }
           
            // Store Metadata
            cube.userData = { ...cube.userData, value: val, originalColor: color, baseY: y };
            return cube;
        }

        function createConnector(p1, p2) {
            const path = new THREE.LineCurve3(p1, p2);
            const geometry = new THREE.TubeGeometry(path, 1, 0.1, 8, false);
            const material = new THREE.MeshBasicMaterial({ color: COLORS.connector, transparent: true, opacity: 0.6 });
            const tube = new THREE.Mesh(geometry, material);
            return tube;
        }

        // Clean Scene
        function clearScene() {
            // Clear Boxes
            objects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            objects = [];
            
            // Clear Standalone Labels (Fixed logic to remove 2D labels)
            labels.forEach(lbl => {
                scene.remove(lbl);
                if (lbl.material && lbl.material.map) lbl.material.map.dispose();
                if (lbl.material) lbl.material.dispose();
            });
            labels = [];

            // Clear Connectors
            connectors.forEach(c => {
                scene.remove(c);
                if(c.geometry) c.geometry.dispose();
                if(c.material) c.material.dispose();
            });
            connectors = [];
        }

        // --- 3. Mode Implementations ---

        let arrayData = [10, 25, 4, 18, 92, 33, 7];
        let matrixData = []; // Store 2D data
        const MATRIX_ROWS = 3;
        const MATRIX_COLS = 3;

        function initMatrixData() {
            if (matrixData.length > 0) return;
            for(let r=0; r<MATRIX_ROWS; r++) {
                let row = [];
                for(let c=0; c<MATRIX_COLS; c++) {
                    row.push(Math.floor(Math.random() * 90) + 10);
                }
                matrixData.push(row);
            }
        }

        const dimensionText = document.getElementById('dimension-text');

        function updateDimensionsDisplay() {
            if (currentMode === '1d') {
                dimensionText.innerText = `Size: ${arrayData.length}`;
            } else {
                dimensionText.innerText = `Matrix: ${MATRIX_ROWS}x${MATRIX_COLS}`;
            }
        }

        function render1DArray() {
            clearScene();
            updateDimensionsDisplay();
            const startX = -(arrayData.length * 2) / 2 + 1;
            
            arrayData.forEach((val, i) => {
                const box = createBox(startX + i * 2, 0, val, COLORS.base);
                
                // Index Label
                const idxMap = createTextTexture(i.toString());
                // Changed color to bright white for visibility
                const idxMat = new THREE.SpriteMaterial({ map: idxMap, color: 0xffffff });
                const idxSprite = new THREE.Sprite(idxMat);
                idxSprite.position.y = -0.5 - (box.geometry.parameters.height/2);
                idxSprite.scale.set(1, 1, 1);
                box.add(idxSprite); // Child of box, removed when box is removed
                
                scene.add(box);
                objects.push(box);
            });

            // Draw Connectors
            for(let i=0; i<objects.length-1; i++) {
                const p1 = objects[i].position.clone();
                const p2 = objects[i+1].position.clone();
                p1.y = -0.5;
                p2.y = -0.5;
                const line = createConnector(p1, p2);
                scene.add(line);
                connectors.push(line);
            }
        }

        function render2DArray() {
            clearScene();
            initMatrixData(); // Ensure data exists
            updateDimensionsDisplay();

            // Vertical Wall Layout (Vertical Grid)
            // INCREASED SPACING to fit labels comfortably
            const spacing = 2.8; 
            const startX = -(MATRIX_COLS * spacing) / 2 + (spacing/2);
            const startY = (MATRIX_ROWS * spacing) / 2 + 2; 

            for(let r=0; r<MATRIX_ROWS; r++) {
                for(let c=0; c<MATRIX_COLS; c++) {
                    const val = matrixData[r][c];
                    const box = createBox(0, 0, val, COLORS.base);
                    
                    // Rotate 90 deg on X so the "top" faces the camera (Z axis)
                    box.rotation.x = Math.PI / 2; 

                    const x = startX + c * spacing;
                    const y = startY - r * spacing; 
                    let z = 0; 

                    box.position.set(x, y, z);
                    
                    // Add index label
                    const label = createTextTexture(`[${r},${c}]`); 
                    const labelMat = new THREE.SpriteMaterial({ map: label, color: 0xffffff });
                    const labelSprite = new THREE.Sprite(labelMat);
                    
                    // Position: Center of the gap below the block.
                    // Block radius ~0.9. Spacing 2.8. Gap is 1.0. Half gap is 0.5.
                    // Center is y - 0.9 - 0.5 = y - 1.4
                    labelSprite.position.set(x, y - 1.4, z + 0.91); 
                    
                    // SCALE INCREASED significantly for visibility
                    labelSprite.scale.set(0.9, 0.9, 1);
                    
                    scene.add(labelSprite);
                    labels.push(labelSprite); 
                    
                    scene.add(box);
                    objects.push(box);
                }
            }
        }

        // --- 4. Operations & Animations ---

        function tween(obj, targetProps, duration = 500, onComplete) {
            const startProps = {};
            for (let k in targetProps) startProps[k] = obj[k];
            const startTime = performance.now();
            function update(time) {
                let elapsed = time - startTime;
                let progress = Math.min(elapsed / duration, 1);
                let ease = 1 - Math.pow(1 - progress, 3);
                for (let k in targetProps) obj[k] = startProps[k] + (targetProps[k] - startProps[k]) * ease;
                if (progress < 1) requestAnimationFrame(update);
                else if (onComplete) onComplete();
            }
            requestAnimationFrame(update);
        }

        function tweenColor(mesh, hexColor, duration = 300) {
            const initial = new THREE.Color(mesh.material.color.getHex());
            const target = new THREE.Color(hexColor);
            const startTime = performance.now();
            function update(time) {
                let progress = Math.min((time - startTime) / duration, 1);
                mesh.material.color.lerpColors(initial, target, progress);
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        function resetColors() {
            objects.forEach(obj => {
                if(obj.userData && obj.userData.originalColor) {
                    tweenColor(obj, obj.userData.originalColor);
                }
            });
        }

        // --- AI Response Logic ---
        function showAIResponse(msg) {
            const container = document.getElementById('ai-response-container');
            const text = document.getElementById('ai-response-text');
            const bubble = document.getElementById('ai-bubble');
            
            // Format bold text for markdown-like effect
            const formatted = msg.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            text.innerHTML = formatted;
            container.classList.remove('hidden');
            
            // Remove thinking animation
            bubble.classList.remove('glass-panel-ai-thinking');
            bubble.classList.add('glass-panel-accent');
            document.getElementById('ai-header').innerText = "AI Insight";
        }

        function showThinking() {
            const container = document.getElementById('ai-response-container');
            const text = document.getElementById('ai-response-text');
            const bubble = document.getElementById('ai-bubble');
            
            container.classList.remove('hidden');
            bubble.classList.remove('glass-panel-accent');
            bubble.classList.add('glass-panel-ai-thinking');
            
            document.getElementById('ai-header').innerText = "Gemini Processing...";
            text.innerText = "Analyzing your request and generating simulation steps...";
        }

        function explainCurrentState() {
            // Manual explanation trigger - SHOWS BUBBLE
            // Context is handled in handleGeminiCommand via 'state' object
            const cmd = "Explain the current state of the data structure.";
            handleGeminiCommand(cmd, true); 
        }

        const aiExplainBtn = document.getElementById('ai-explain-btn');
        aiExplainBtn.addEventListener('click', explainCurrentState);

        // --- 1D Visualizations ---

        async function visualizeLinearSearch(val) {
            if(isAnimating) return;
            isAnimating = true;
            resetColors();
            updateStatus(`Searching for value: ${val}...`);
            
            for(let i=0; i<arrayData.length; i++) {
                const box = objects[i];
                if(!box.geometry) continue; 
                
                tweenColor(box, COLORS.highlight);
                updateStatus(`Checking index ${i}: Value ${arrayData[i]}`);
                await new Promise(r => setTimeout(r, 600));

                if(arrayData[i] == val) {
                    tweenColor(box, COLORS.success);
                    const originalY = box.position.y;
                    tween(box.position, {y: originalY + 1.5}, 200, () => {
                        tween(box.position, {y: originalY}, 200);
                    });
                    updateStatus(`Found ${val} at index ${i}!`);
                    isAnimating = false;
                    return;
                } else {
                    tweenColor(box, COLORS.base);
                }
            }
            updateStatus(`Value ${val} not found.`);
            isAnimating = false;
        }

        async function visualizeInsertion(index, value) {
            if (isAnimating) return;
            if (index < 0) index = 0;
            if (index > arrayData.length) index = arrayData.length;

            isAnimating = true;
            updateStatus(`Inserting ${value} at index ${index}...`);
            
            // 1. Calculate new center and positions
            const newLength = arrayData.length + 1;
            const startX = -(newLength * 2) / 2 + 1;
            
            // 2. Animate existing blocks
            const shiftPromises = [];
            for(let i=0; i<index; i++) {
                const targetX = startX + i * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, {x: targetX}, 600, r)));
            }
            for(let i=index; i<objects.length; i++) {
                const targetX = startX + (i + 1) * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, {x: targetX}, 600, r)));
            }
            
            await Promise.all(shiftPromises);
            await new Promise(r => setTimeout(r, 100));

            // 3. Update Data
            arrayData.splice(index, 0, value);
            render1DArray();
            
            // 4. Animate New Entry
            const newBox = objects[index];
            if(newBox) {
                newBox.scale.set(0.1, 0.1, 0.1);
                tweenColor(newBox, COLORS.success);
                tween(newBox.scale, {x: 1, y: 1, z: 1}, 400);
                await new Promise(r => setTimeout(r, 600));
                tweenColor(newBox, COLORS.base);
            }

            updateStatus(`Inserted ${value} at index ${index}.`);
            isAnimating = false;
        }

        async function visualizeDeletion(index) {
            if (isAnimating) return;
            if (index < 0 || index >= arrayData.length) { updateStatus("Invalid Index"); return; }
            isAnimating = true;
            updateStatus(`Deleting element at index ${index}...`);

            const targetBox = objects[index];
            
            // 1. Shrink Target
            tweenColor(targetBox, COLORS.delete);
            tween(targetBox.scale, {x: 0.1, y: 0.1, z: 0.1}, 400);
            await new Promise(r => setTimeout(r, 450));

            // 2. Calculate new center
            const newLength = arrayData.length - 1;
            const startX = -(newLength * 2) / 2 + 1;

            // 3. Shift remaining items
            const shiftPromises = [];
            for(let i=0; i<index; i++) {
                const targetX = startX + i * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, {x: targetX}, 600, r)));
            }
            for(let i=index+1; i<objects.length; i++) {
                const targetX = startX + (i - 1) * 2;
                shiftPromises.push(new Promise(r => tween(objects[i].position, {x: targetX}, 600, r)));
            }

            if(shiftPromises.length > 0) await Promise.all(shiftPromises);
            await new Promise(r => setTimeout(r, 100));

            // 4. Finalize
            arrayData.splice(index, 1);
            render1DArray();
            updateStatus(`Deleted element at index ${index}.`);
            isAnimating = false;
        }

        // --- 2D Visualizations ---

        async function visualizeUpdate2D(row, col, value) {
            if(isAnimating) return;
            if(row < 0 || row >= MATRIX_ROWS || col < 0 || col >= MATRIX_COLS) return;

            isAnimating = true;
            updateStatus(`Updating cell [${row},${col}] to ${value}...`);

            // Index in flattened array
            const idx = row * MATRIX_COLS + col;
            const box = objects[idx];

            if(box) {
                // Highlight
                tweenColor(box, COLORS.highlight);
                const originalScale = box.scale.clone();
                tween(box.scale, {x: 1.2, y: 1.2, z: 1.2}, 300);
                await new Promise(r => setTimeout(r, 400));

                // Update Data
                matrixData[row][col] = value;
                
                // Update Visual Sprite
                if(box.userData.sprite) {
                    const newMap = createTextTexture(value.toString());
                    box.userData.sprite.material.map = newMap;
                }

                // Finish
                tweenColor(box, COLORS.success);
                await new Promise(r => setTimeout(r, 300));
                tween(box.scale, {x: 1, y: 1, z: 1}, 300);
                tweenColor(box, COLORS.base);
            }
            
            updateStatus(`Updated cell [${row},${col}].`);
            isAnimating = false;
        }

        async function visualizeSearch2D(val) {
            if(isAnimating) return;
            isAnimating = true;
            resetColors();
            updateStatus(`Searching matrix for ${val}...`);
            let found = false;

            for(let r=0; r<MATRIX_ROWS; r++) {
                for(let c=0; c<MATRIX_COLS; c++) {
                    const idx = r * MATRIX_COLS + c;
                    const box = objects[idx];
                    const cellVal = matrixData[r][c];

                    tweenColor(box, COLORS.highlight, 100);
                    updateStatus(`Checking [${r},${c}]...`);
                    await new Promise(r => setTimeout(r, 250));

                    if(cellVal == val) {
                        tweenColor(box, COLORS.success);
                        // Vertical Layout: Move towards Camera (Z axis)
                        // Standard Layout: Move Up (Y axis)
                        // Check if rotated (rotation.x is roughly PI/2)
                        const isVertical = Math.abs(box.rotation.x - Math.PI/2) < 0.1;
                        
                        if(isVertical) {
                             tween(box.position, {z: box.position.z + 1.5}, 200, () => {
                                 tween(box.position, {z: box.position.z - 1.5}, 200);
                             });
                        } else {
                             tween(box.position, {y: box.position.y + 1}, 200, () => {
                                 tween(box.position, {y: box.position.y - 1}, 200);
                             });
                        }
                        
                        found = true;
                        updateStatus(`Found ${val} at [${r},${c}]`);
                        isAnimating = false;
                        return;
                    } else {
                         tweenColor(box, COLORS.base, 100);
                    }
                }
            }

            if(!found) updateStatus(`Value ${val} not found in matrix.`);
            isAnimating = false;
        }

        // --- 5. UI & Event Handling ---
        const controlsContainer = document.getElementById('controls-container');
        const modeSelect = document.getElementById('mode-select');
        const statusText = document.getElementById('status-text');
        // Removed toggleViewBtn
        const aiModeBtn = document.getElementById('ai-mode-btn');
        const aiCommandContainer = document.getElementById('ai-command-container');
        const aiInput = document.getElementById('ai-input');
        const aiSubmitBtn = document.getElementById('ai-submit-btn');

        function updateStatus(msg) {
            statusText.innerText = msg;
            statusText.parentElement.classList.remove('animate-pulse');
            void statusText.parentElement.offsetWidth;
            statusText.parentElement.classList.add('animate-pulse');
        }

        function createButton(text, iconName, onClick, primary=true, isDanger=false) {
            const btn = document.createElement('button');
            let cls = primary 
                ? "btn-primary text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none"
                : "bg-gray-700 hover:bg-gray-600 text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none transition";
            
            if(isDanger) cls = "btn-danger text-white font-medium py-1.5 px-3 rounded-r-lg text-sm flex items-center gap-2 whitespace-nowrap rounded-l-none";
            
            btn.className = cls;
            btn.innerHTML = `<i data-lucide="${iconName}" class="w-4 h-4"></i>`;
            btn.onclick = onClick;
            return btn;
        }

        function createInput(placeholder, width='w-12', value='', rounded='rounded-l-lg') {
            const input = document.createElement('input');
            input.type = 'number';
            input.placeholder = placeholder;
            if(value) input.value = value;
            input.className = `bg-gray-800 text-white text-xs px-2 py-1.5 outline-none border border-gray-600 focus:bg-gray-700 transition ${width} text-center placeholder-gray-500 ${rounded}`;
            return input;
        }

        function createControlGroup(elements) {
            const wrapper = document.createElement('div');
            wrapper.className = "flex items-center shadow-lg mr-2";
            elements.forEach(el => wrapper.appendChild(el));
            return wrapper;
        }

        function updateControls() {
            controlsContainer.innerHTML = '';
            
            if (currentMode === '1d') {
                // 1. Linear Search
                const searchIn = createInput('Val', 'w-12', '18');
                const searchBtn = createButton('Search', 'search', () => {
                   const val = parseInt(searchIn.value);
                   if (!isNaN(val)) visualizeLinearSearch(val);
                });
                controlsContainer.appendChild(createControlGroup([searchIn, searchBtn]));

                // 2. Insert
                const insIdx = createInput('Index', 'w-16', '', 'rounded-l-lg border-r-0');
                const insVal = createInput('Value', 'w-16', '', 'rounded-none');
                const insBtn = createButton('Insert', 'plus-square', () => {
                    const i = parseInt(insIdx.value);
                    const v = parseInt(insVal.value);
                    if(isNaN(i) || isNaN(v)) { updateStatus("Enter Index & Value"); return; }
                    visualizeInsertion(i, v);
                });
                controlsContainer.appendChild(createControlGroup([insIdx, insVal, insBtn]));

                // 3. Delete
                const delIdx = createInput('Index', 'w-16', '');
                const delBtn = createButton('Delete', 'trash-2', () => {
                    const i = parseInt(delIdx.value);
                    if(isNaN(i)) { updateStatus("Enter Index"); return; }
                    visualizeDeletion(i);
                }, true, true);
                controlsContainer.appendChild(createControlGroup([delIdx, delBtn]));

            } else if (currentMode === '2d') {
                const travBtn = document.createElement('button');
                travBtn.className = "btn-primary text-white font-medium py-1.5 px-4 rounded-lg text-sm flex items-center gap-2 whitespace-nowrap";
                travBtn.innerHTML = `<i data-lucide="grid" class="w-4 h-4"></i> Traverse`;
                travBtn.onclick = async () => {
                    if(isAnimating) return;
                    isAnimating = true;
                    resetColors();
                    updateStatus("Traversing 2D Array (Row-Major)...");
                    for(let i=0; i<objects.length; i++) {
                        const box = objects[i];
                        // Calc grid coords from index
                        const r = Math.floor(i / MATRIX_COLS);
                        const c = i % MATRIX_COLS;
                        const coords = `[${r}, ${c}]`;
                        
                        tweenColor(box, COLORS.highlight, 150);
                        updateStatus(`Visiting ${coords}`);
                        await new Promise(r => setTimeout(r, 400));
                        tweenColor(box, COLORS.success, 150);
                    }
                    updateStatus("Traversal Complete.");
                    isAnimating = false;
                };
                controlsContainer.appendChild(travBtn);
            }
            lucide.createIcons();
        }

        // --- GEMINI AI INTEGRATION ---
        
        async function callGeminiAPI(userPrompt) {
            const apiKey = ""; // Injected by environment
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            
            // Construct the system state
            // FIX: Send matrixData if in 2d mode so Gemini knows the grid values
            const stateData = currentMode === '1d' ? arrayData : matrixData;
            const state = {
                mode: currentMode,
                data: stateData,
                structure: currentMode === '1d' ? "Array (Linear)" : "Matrix (4x4 Grid)"
            };

            const systemPrompt = `
            You are an AI controller for a 3D Array Visualizer. 
            Current State: ${JSON.stringify(state)}.
            
            Your goal is to interpret the user's natural language request and return a JSON object with a list of commands to execute.
            
            Available Commands (use these exact names):
            - insert(index, value): Inserts 'value' at 'index' (1D Only).
            - delete(index): Deletes element at 'index' (1D Only).
            - search(value): Linear searches for 'value' (1D Only).
            - update2D(row, col, value): Updates cell at [row,col] with 'value' (2D Mode Only).
            - search2D(value): Searches for 'value' in the matrix (2D Mode Only).
            - clear(): Resets array to empty (1D Only).
            - reset(): Resets to default state.
            - fill(count): Fills array with 'count' random numbers (1D Only).
            - setMode(mode): '1d' or '2d'.
            
            Response Format (JSON ONLY):
            {
                "explanation": "Brief explanation of what you are doing (max 2 sentences). Use Markdown for bolding key terms.",
                "commands": [
                    { "cmd": "commandName", "args": [arg1, arg2] }
                ]
            }
            
            Example 1: User "Replace the second item with 50" (1D)
            Response: { "explanation": "I will **delete** the item at index 1 and **insert** 50 in its place.", "commands": [ { "cmd": "delete", "args": [1] }, { "cmd": "insert", "args": [1, 50] } ] }

            Example 2: User "Set the top left corner to 99" (2D)
            Response: { "explanation": "I will update the cell at row 0, column 0 to **99**.", "commands": [ { "cmd": "update2D", "args": [0, 0, 99] } ] }
            `;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userPrompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                if (!response.ok) throw new Error("API Error");
                
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("No response text");
                
                return JSON.parse(text);
            } catch (error) {
                console.error(error);
                return { 
                    explanation: "I encountered an error connecting to the AI brain. Please try again.", 
                    commands: [] 
                };
            }
        }

        async function executeAICommands(commandList) {
            for (const item of commandList) {
                const { cmd, args } = item;
                
                // Wait for any running animation to finish before starting next step
                while(isAnimating) {
                    await new Promise(r => setTimeout(r, 100));
                }

                // Check mode compatibility
                if (currentMode === '2d' && ['insert', 'delete', 'search'].includes(cmd)) {
                     updateStatus(`Command '${cmd}' not available in 2D mode.`);
                     continue;
                }
                if (currentMode === '1d' && ['update2D', 'search2D'].includes(cmd)) {
                     updateStatus(`Command '${cmd}' not available in 1D mode.`);
                     continue;
                }

                switch(cmd) {
                    case 'insert': await visualizeInsertion(args[0], args[1]); break;
                    case 'delete': await visualizeDeletion(args[0]); break;
                    case 'search': await visualizeLinearSearch(args[0]); break;
                    
                    // New 2D Commands
                    case 'update2D': await visualizeUpdate2D(args[0], args[1], args[2]); break;
                    case 'search2D': await visualizeSearch2D(args[0]); break;

                    case 'setMode': 
                        modeSelect.value = args[0]; 
                        modeSelect.dispatchEvent(new Event('change')); 
                        break;
                    case 'clear':
                        if(currentMode === '1d') {
                            arrayData = [];
                            render1DArray();
                            updateStatus("Cleared Array");
                        }
                        break;
                    case 'reset':
                        if(currentMode === '1d') {
                            arrayData = [10, 25, 4, 18, 92, 33, 7];
                            render1DArray();
                        } else {
                            matrixData = []; // Clear to force re-init
                            render2DArray(); // Will call initMatrixData
                        }
                        updateStatus("Reset Data");
                        break;
                    case 'fill':
                        if(currentMode === '1d') {
                            const count = Math.min(args[0] || 5, 15);
                            arrayData = Array.from({length: count}, () => Math.floor(Math.random() * 99) + 1);
                            render1DArray();
                            updateStatus(`Generated ${count} random numbers`);
                        }
                        break;
                }
                
                // Small pause between chained commands
                await new Promise(r => setTimeout(r, 500));
            }
        }

        async function handleGeminiCommand(forcedCmd = null, showBubble = false) {
            const inputVal = forcedCmd || aiInput.value.trim();
            if (!inputVal) return;
            
            if(!forcedCmd) aiInput.value = ''; // Clear input if from UI
            
            // Handle Bubble Visibility based on flag
            const bubbleContainer = document.getElementById('ai-response-container');
            if (showBubble) {
                showThinking();
            } else {
                // Ensure it's hidden if user didn't ask for it
                bubbleContainer.classList.add('hidden');
                updateStatus("AI Processing...");
            }
            
            // 1. Get AI Plan
            const aiResult = await callGeminiAPI(inputVal);
            
            // 2. Show Explanation
            if (showBubble) {
                showAIResponse(aiResult.explanation);
            } else {
                // Show condensed explanation in status bar for regular commands
                const cleanText = aiResult.explanation.replace(/\*\*/g, '').replace(/\*/g, '');
                updateStatus(cleanText); 
            }
            
            // 3. Execute Commands
            if (aiResult.commands && aiResult.commands.length > 0) {
                if (showBubble) updateStatus("AI executing simulation steps...");
                await executeAICommands(aiResult.commands);
                updateStatus("AI Simulation Complete");
            }
        }

        aiSubmitBtn.addEventListener('click', () => handleGeminiCommand(null, false));
        aiInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') handleGeminiCommand(null, false); });

        // Toggle AI Mode UI
        aiModeBtn.addEventListener('click', () => {
            isAIMode = !isAIMode;
            
            if(isAIMode) {
                // Switch to AI
                controlsContainer.classList.add('hidden');
                
                aiCommandContainer.classList.remove('hidden');
                aiCommandContainer.classList.add('flex');
                
                // Trigger Animation
                aiCommandContainer.classList.remove('fade-in');
                void aiCommandContainer.offsetWidth; // Reflow
                aiCommandContainer.classList.add('fade-in');

                aiModeBtn.innerHTML = '<i data-lucide="x" class="w-4 h-4"></i>';
                aiInput.focus();
                updateStatus("AI Command Mode Active");
            } else {
                // Switch to Manual
                aiCommandContainer.classList.add('hidden');
                aiCommandContainer.classList.remove('flex');

                controlsContainer.classList.remove('hidden');
                
                // Trigger Animation
                controlsContainer.classList.remove('fade-in');
                void controlsContainer.offsetWidth; // Reflow
                controlsContainer.classList.add('fade-in');

                aiModeBtn.innerHTML = '<i data-lucide="bot" class="w-4 h-4"></i>';
                updateStatus("Manual Control Mode");
            }
            lucide.createIcons();
        });

        function rerender() {
            switch(currentMode) {
                case '1d': render1DArray(); break;
                case '2d': render2DArray(); break;
            }
        }

        modeSelect.addEventListener('change', (e) => {
            currentMode = e.target.value;
            // Only reset data if switching to 1d from something else to avoid wiping customization
            if (currentMode === '1d' && arrayData.length === 0) arrayData = [10, 25, 4, 18, 92, 33, 7];
            
            updateStatus(`${currentMode.toUpperCase()} mode loaded.`);
            rerender();
            updateControls();
        });

        // Removed toggleViewBtn Event Listener

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        render1DArray();
        updateControls();
        animate();
        lucide.createIcons();
    </script>
</body>
</html>
