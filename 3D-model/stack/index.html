<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Stack Visualization - DSA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 260px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Header Layout */
        .ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 1.1rem;
            color: #61dafb;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        /* Minimize Button */
        #minimize-btn {
            background: transparent;
            border: 1px solid #444;
            color: #ccc;
            width: 24px;
            height: 24px;
            padding: 0;
            font-size: 14px;
            line-height: 1;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #minimize-btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
            border-color: #666;
        }

        /* Collapsible Body */
        #ui-body {
            display: block;
        }

        #ui-container.collapsed {
            width: auto;
            min-width: 120px;
            height: auto;
            overflow: hidden;
        }

        #ui-container.collapsed #ui-body {
            display: none;
        }

        /* Controls */
        .control-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        input, textarea {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #2a2a2a;
            color: white;
            font-size: 0.9rem;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }

        input:focus, textarea:focus {
            border-color: #61dafb;
        }
        
        textarea {
            resize: none;
            height: 60px;
            margin-bottom: 5px;
        }

        button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.75rem;
        }

        .btn-push { background: #61dafb; color: #000; flex: 1; }
        .btn-push:hover { background: #4fa8d1; }
        .btn-push:active { transform: scale(0.95); }

        .btn-pop { background: #ff6b6b; color: white; width: 100%; margin-top: 5px;}
        .btn-pop:hover { background: #e05e5e; }

        .btn-peek { background: #feca57; color: #333; width: 48%; }
        .btn-clear { background: #ff9f43; color: #333; width: 48%; }

        /* AI Section Styles */
        .ai-section {
            margin-top: 15px;
            border-top: 1px solid #444;
            padding-top: 10px;
        }
        
        .ai-label {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 8px;
            display: block;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-actions {
            display: flex;
            gap: 5px;
        }

        .btn-ai-run { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; flex: 1; }
        .btn-ai-explain { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; flex: 1; }
        
        .btn-ai-run:hover, .btn-ai-explain:hover { filter: brightness(1.1); }
        .btn-ai-run:disabled, .btn-ai-explain:disabled { opacity: 0.5; cursor: not-allowed; }

        #ai-status {
            margin-top: 8px;
            font-size: 0.8rem;
            color: #d1d1d1;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 4px;
            min-height: 20px;
            border-left: 3px solid #61dafb;
            white-space: pre-wrap;
        }

        .status-panel {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: #ccc;
        }

        .status-value {
            font-weight: bold;
            color: #fff;
        }

        #message-log {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #888;
            font-style: italic;
            height: 16px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Tutorial/Help Text */
        #help-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div class="ui-header">
            <h1>Stack DSA</h1>
            <button id="minimize-btn" onclick="toggleUI()" title="Toggle Controls">_</button>
        </div>
        
        <div id="ui-body">
            <!-- Standard Controls -->
            <div class="control-group">
                <input type="text" id="push-value" placeholder="Value (e.g. 42)" onkeypress="handleEnter(event)">
                <button class="btn-push" onclick="triggerPush()">Push</button>
            </div>

            <div class="control-group">
                <button class="btn-peek" onclick="triggerPeek()">Peek</button>
                <button class="btn-clear" onclick="triggerClear()">Clear</button>
            </div>
            
            <button class="btn-pop" onclick="triggerPop()">Pop</button>

            <!-- AI Section -->
            <div class="ai-section">
                <span class="ai-label">âœ¨ AI Command Center</span>
                <textarea id="ai-prompt" placeholder="Ex: 'Push 5 random numbers' or 'Explain this stack'"></textarea>
                <div class="ai-actions">
                    <button class="btn-ai-run" onclick="runAICommand()">Simulate</button>
                    <button class="btn-ai-explain" onclick="explainStack()">Explain</button>
                </div>
                <div id="ai-status">Ready for AI commands...</div>
            </div>

            <!-- Stats -->
            <div class="status-panel">
                <div class="status-item">
                    <span>Top:</span>
                    <span id="status-top" class="status-value">null</span>
                </div>
                <div class="status-item">
                    <span>Size:</span>
                    <span id="status-size" class="status-value">0</span>
                </div>
                <div id="message-log">Ready...</div>
            </div>
        </div>
    </div>

    <div id="help-text">Click & Drag to Rotate View | Scroll to Zoom</div>
    <div id="canvas-container"></div>

    <script>
        // --- Gemini API Configuration ---
        const apiKey = ""; // API key will be injected here
        const AI_MODEL = "gemini-2.5-flash-preview-09-2025";

        async function callGemini(prompt, systemInstruction = "You are a helpful assistant.", jsonMode = false) {
            const statusBox = document.getElementById('ai-status');
            statusBox.innerText = "Thinking...";
            statusBox.style.opacity = "0.7";

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL}:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            if (jsonMode) {
                payload.generationConfig = { responseMimeType: "application/json" };
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error("AI Busy. Try again.");

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                
                statusBox.style.opacity = "1";
                return text;
            } catch (error) {
                statusBox.innerText = "Error: " + error.message;
                statusBox.style.opacity = "1";
                return null;
            }
        }

        async function runAICommand() {
            const userPrompt = document.getElementById('ai-prompt').value;
            if (!userPrompt.trim()) return;

            // System prompt to force JSON output for simulation
            const systemPrompt = `You are a controller for a Stack visualization. 
            Convert the user's natural language request into a strictly valid JSON array of operations.
            Valid operations are:
            {"type": "push", "value": "some_string_or_number"}
            {"type": "pop"}
            {"type": "clear"}
            
            Example: User "Add 3 even numbers" -> [{"type":"push", "value":2}, {"type":"push", "value":4}, {"type":"push", "value":6}]
            Do not output markdown code blocks. Just the raw JSON.`;

            const result = await callGemini(userPrompt, systemPrompt, true);
            
            if (result) {
                try {
                    let operations = JSON.parse(result);
                    if (!Array.isArray(operations)) operations = [operations];
                    
                    document.getElementById('ai-status').innerText = `Executing ${operations.length} actions...`;
                    
                    // Execute sequentially with delay for animation
                    for (const op of operations) {
                        if (op.type === 'push') pushToStack(op.value);
                        else if (op.type === 'pop') triggerPop();
                        else if (op.type === 'clear') triggerClear();
                        
                        // Wait 600ms between actions
                        await new Promise(r => setTimeout(r, 600));
                    }
                    document.getElementById('ai-status').innerText = "Simulation complete.";

                } catch (e) {
                    document.getElementById('ai-status').innerText = "Failed to parse AI actions.";
                    console.error(e);
                }
            }
        }

        async function explainStack() {
            const currentItems = stack.map(item => item.value);
            const stackDesc = currentItems.length > 0 
                ? `The stack currently has ${stack.length} items. From bottom to top, they are: [${currentItems.join(', ')}].`
                : `The stack is currently empty.`;

            const prompt = `Here is the current state of a Stack Data Structure: ${stackDesc}. 
            Explain this state to a student. Mention which item is at the "Top" and would be removed next (LIFO principle). Keep it under 3 sentences.`;

            const explanation = await callGemini(prompt, "You are a Computer Science Tutor.");
            if (explanation) {
                document.getElementById('ai-status').innerText = explanation;
            }
        }


        // --- Configuration ---
        const BOX_SIZE = 2;
        const BOX_HEIGHT = 1;
        const GAP = 0.1;
        
        // --- Globals ---
        let scene, camera, renderer;
        let stack = []; 
        let platform;
        
        // Camera Interaction
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = Math.PI / 4;
        let cameraHeight = 10;
        let cameraRadius = 20;

        // Animations Queue
        let animations = []; 

        // --- Initialization ---
        function init() {
            // 1. Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 20, 60);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const spotLight = new THREE.SpotLight(0x61dafb, 0.5);
            spotLight.position.set(-10, 10, -5);
            spotLight.lookAt(0, 0, 0);
            scene.add(spotLight);

            // 5. Environment (Platform)
            createPlatform();

            // 6. Events
            window.addEventListener('resize', onWindowResize, false);
            setupMouseControls();

            // 7. Start Loop
            animate();
        }

        function createPlatform() {
            const geometry = new THREE.CylinderGeometry(6, 6.5, 1, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.2
            });
            platform = new THREE.Mesh(geometry, material);
            platform.position.y = -0.5;
            platform.receiveShadow = true;
            scene.add(platform);

            // Add a base ring
            const ringGeo = new THREE.TorusGeometry(6.5, 0.2, 8, 50);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x61dafb });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -0.8;
            scene.add(ring);
        }

        // --- Helper: Dynamic Texture for Text ---
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#ffffff'; // White background for the face
            ctx.fillRect(0, 0, 256, 256);

            // Border
            ctx.lineWidth = 20;
            ctx.strokeStyle = '#61dafb';
            ctx.strokeRect(0, 0, 256, 256);

            // Text
            ctx.font = 'bold 100px Arial';
            ctx.fillStyle = '#333333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- Stack Operations ---

        function triggerPush() {
            const input = document.getElementById('push-value');
            const val = input.value.trim();
            if (val === "") return;

            // Visual limit
            if (stack.length >= 15) {
                logMessage("Full!", true);
                return;
            }

            pushToStack(val);
            input.value = "";
            input.focus();
        }

        function pushToStack(value) {
            // Calculate target position
            const targetY = (stack.length * (BOX_HEIGHT + GAP)) + (BOX_HEIGHT / 2);
            
            // Create Geometry
            const geometry = new THREE.BoxGeometry(BOX_SIZE, BOX_HEIGHT, BOX_SIZE);
            
            // Create Materials (Text on sides, color on top/bottom)
            const texture = createTextTexture(value);
            const plainMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const textMat = new THREE.MeshStandardMaterial({ map: texture });
            
            // Order: x+, x-, y+, y-, z+, z-
            const materials = [textMat, textMat, plainMat, plainMat, textMat, textMat];

            const mesh = new THREE.Mesh(geometry, materials);
            
            // Initial position (Spawn high above)
            mesh.position.set(0, 20, 0); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);

            const stackItem = {
                value: value,
                mesh: mesh,
                targetY: targetY,
                isAnimating: true
            };

            stack.push(stackItem);
            updateUI();
            logMessage(`Pushed ${value}`);
        }

        function triggerPop() {
            if (stack.length === 0) {
                logMessage("Empty!", true);
                return;
            }

            const item = stack.pop();
            
            // Animation for popping (Up and Fade)
            const popAnimation = () => {
                if(!item.mesh) return true; // Done

                item.mesh.position.y += 0.5; // Move up
                item.mesh.rotation.x += 0.1; // Spin
                item.mesh.rotation.z += 0.1;
                
                if (item.mesh.position.y > 20) {
                    scene.remove(item.mesh);
                    item.mesh.geometry.dispose();
                    return true; // Remove from animation list
                }
                return false; // Keep animating
            };
            
            animations.push(popAnimation);
            updateUI();
            logMessage(`Popped ${item.value}`);
        }

        function triggerPeek() {
            if (stack.length === 0) {
                logMessage("Stack is empty.");
                return;
            }
            
            const topItem = stack[stack.length - 1];
            logMessage(`Top is ${topItem.value}`);
            
            // Highlight Animation
            const originalColor = topItem.mesh.material[2].color.getHex();
            topItem.mesh.material.forEach(m => {
                if(m.color) m.color.setHex(0xfeca57); // Gold
            });

            // Reset after 1 second
            setTimeout(() => {
                if (topItem && topItem.mesh) {
                     topItem.mesh.material.forEach(m => {
                         if(!m.map) m.color.setHex(0xffffff); // Reset top/bottom
                         else m.color.setHex(0xffffff); // Reset sides tint
                     });
                }
            }, 500);
        }

        function triggerClear() {
            if(stack.length === 0) return;
            
            // Clear all visually
            stack.forEach(item => {
                scene.remove(item.mesh);
                item.mesh.geometry.dispose();
            });
            
            stack = [];
            updateUI();
            logMessage("Cleared.");
        }

        function toggleUI() {
            const container = document.getElementById('ui-container');
            const btn = document.getElementById('minimize-btn');
            container.classList.toggle('collapsed');
            
            if (container.classList.contains('collapsed')) {
                btn.innerText = "+";
            } else {
                btn.innerText = "_";
            }
        }

        // --- Logic & Loop ---

        function updateUI() {
            document.getElementById('status-size').innerText = stack.length;
            const topVal = stack.length > 0 ? stack[stack.length - 1].value : "null";
            document.getElementById('status-top').innerText = topVal;
        }

        function logMessage(msg, isError = false) {
            const el = document.getElementById('message-log');
            el.innerText = msg;
            el.style.color = isError ? '#ff6b6b' : '#888';
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. Handle Physics/Tweens for Stack Items
            stack.forEach(item => {
                // Lerp Y position
                if (Math.abs(item.mesh.position.y - item.targetY) > 0.01) {
                    item.mesh.position.y += (item.targetY - item.mesh.position.y) * 0.15;
                } else {
                    item.mesh.position.y = item.targetY;
                }
            });

            // 2. Handle One-off Animations (like Pop)
            for (let i = animations.length - 1; i >= 0; i--) {
                const finished = animations[i]();
                if (finished) {
                    animations.splice(i, 1);
                }
            }

            // 3. Render
            renderer.render(scene, camera);
        }

        // --- Controls & Events ---

        function handleEnter(e) {
            if (e.key === 'Enter') triggerPush();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraPosition() {
            const x = cameraRadius * Math.sin(cameraAngle);
            const z = cameraRadius * Math.cos(cameraAngle);
            camera.position.set(x, cameraHeight, z);
            camera.lookAt(0, stack.length * 0.5, 0); // Look slightly up as stack grows
        }

        function setupMouseControls() {
            const el = renderer.domElement;

            el.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                // Rotate logic
                cameraAngle -= deltaMove.x * 0.01;
                
                // Height logic (optional zoom/pitch)
                cameraHeight += deltaMove.y * 0.1;
                cameraHeight = Math.max(5, Math.min(cameraHeight, 40));

                updateCameraPosition();

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            // Zoom (Scroll)
            el.addEventListener('wheel', (e) => {
                cameraRadius += e.deltaY * 0.05;
                cameraRadius = Math.max(10, Math.min(cameraRadius, 50));
                updateCameraPosition();
            });
        }

        // Start
        init();
        
        // Initial Demo Data
        setTimeout(() => pushToStack(10), 500);
        setTimeout(() => pushToStack(20), 1000);
        setTimeout(() => pushToStack(30), 1500);

    </script>
</body>
</html>
