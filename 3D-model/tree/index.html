<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tree Data Structure Visualizer with Gemini AI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-panel {
            position: absolute;
            top: 70px;
            left: 20px;
            width: 280px;
            background: rgba(20, 25, 35, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            max-height: 85vh;
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
            scrollbar-width: thin;
            scrollbar-color: #4facfe rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* Custom Scrollbar */
        #ui-panel::-webkit-scrollbar { width: 6px; }
        #ui-panel::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 4px; }
        #ui-panel::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        #ui-panel::-webkit-scrollbar-thumb:hover { background: #4facfe; }

        #ui-toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2000;
            padding: 10px 20px;
            background: rgba(20, 25, 35, 0.9);
            color: #4facfe;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        #ui-toggle-btn:hover { background: rgba(30, 35, 45, 1); transform: translateY(-1px); }
        #ui-toggle-btn:active { transform: scale(0.98); }

        h1 { 
            margin: 0 0 10px 0; font-size: 1.2rem; 
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); 
            padding-bottom: 8px; font-weight: 800; letter-spacing: 0.5px;
        }
        
        .control-group { margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 12px; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; font-size: 0.75rem; margin-bottom: 4px; color: #8fa3bf; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; }
        
        select, input[type="number"], textarea, input[type="text"] {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: #fff;
            margin-bottom: 8px;
            outline: none;
            box-sizing: border-box;
            transition: border-color 0.2s;
            font-family: inherit;
            font-size: 0.85rem;
            resize: vertical;
        }
        select:focus, input:focus, textarea:focus { border-color: #4facfe; background: rgba(0,0,0,0.5); }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .btn-full { width: 100%; margin-top: 4px; }
        
        button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none; padding: 8px; border-radius: 8px;
            color: #001e3c; font-weight: 700; cursor: pointer;
            transition: all 0.2s; font-size: 0.8rem;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.3);
        }
        button:hover { opacity: 0.95; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4); }
        button:active { transform: scale(0.98); }
        
        button.secondary {
            background: rgba(255, 255, 255, 0.08); color: #cceeff;
            border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: none; font-weight: 500;
        }
        button.secondary:hover { background: rgba(255, 255, 255, 0.15); border-color: rgba(255,255,255,0.3); color: #fff; }
        
        button.danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%); color: white;
            box-shadow: 0 2px 8px rgba(255, 75, 43, 0.3);
        }
        button.danger:hover { box-shadow: 0 4px 12px rgba(255, 75, 43, 0.4); }

        /* Updated AI Button to match Main Theme */
        button.ai-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: #001e3c;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.3);
        }
        button.ai-btn:hover { box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4); }

        /* Stats Panel */
        .stats-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
            margin-bottom: 12px; background: rgba(0,0,0,0.2); padding: 10px;
            border-radius: 10px; border: 1px solid rgba(255,255,255,0.05);
        }
        .stat-box { text-align: center; }
        .stat-val { font-size: 1.1rem; font-weight: bold; color: #00f2fe; text-shadow: 0 0 10px rgba(0, 242, 254, 0.3); }
        .stat-label { font-size: 0.6rem; color: #8fa3bf; text-transform: uppercase; letter-spacing: 1px; margin-top: 3px; }

        #status-log {
            margin-top: 8px; padding: 8px; background: rgba(0, 0, 0, 0.3);
            border-radius: 8px; font-family: 'Consolas', monospace;
            font-size: 0.75rem; height: 60px; overflow-y: auto;
            color: #7dd3fc; border-left: 3px solid #4facfe; line-height: 1.4;
        }
        
        /* Updated AI Log to match Main Theme */
        #ai-log {
            margin-top: 8px; padding: 10px; background: rgba(20, 30, 40, 0.5);
            border-radius: 8px; font-family: 'Segoe UI', sans-serif;
            font-size: 0.75rem; height: auto; min-height: 60px; max-height: 150px; overflow-y: auto;
            color: #7dd3fc; border-left: 3px solid #4facfe; line-height: 1.4;
            display: none;
        }

        .legend {
            margin-top: 15px; display: flex; gap: 10px; justify-content: center;
            font-size: 0.75rem; color: #aaa;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; display: flex; justify-content: center; align-items: center;
            z-index: 1000; color: #4facfe; font-size: 1.5rem; transition: opacity 0.5s;
        }
        
        .loading-spinner::after {
            content: " ‚è≥";
            animation: spin 1s infinite linear;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <!-- Import Three.js and FontLoader -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">Loading 3D Engine...</div>
    <div id="canvas-container"></div>

    <!-- Toggle Button -->
    <button id="ui-toggle-btn" onclick="toggleUI()">
        <span>üëÅÔ∏è</span> Toggle Controls
    </button>

    <div id="ui-panel">
        <h1>Tree Visualizer</h1>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-val" id="stat-height">0</div>
                <div class="stat-label">Tree Height</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="stat-nodes">0</div>
                <div class="stat-label">Total Nodes</div>
            </div>
        </div>

        <!-- Gemini AI Section (Updated Colors) -->
        <div class="control-group" style="border-color: rgba(79, 172, 254, 0.2);">
            <label style="color: #4facfe;">Gemini AI Assistant</label>
            <textarea id="ai-prompt" rows="2" placeholder="e.g. 'Insert 10, 20, 30 then search for 20'"></textarea>
            <div class="btn-grid">
                <button class="ai-btn" onclick="runAISimulation()" id="btn-simulate">Auto Simulate</button>
                <button class="ai-btn secondary" onclick="explainState()" id="btn-explain">Explain State</button>
            </div>
            <div id="ai-log">AI Responses will appear here...</div>
        </div>

        <div class="control-group">
            <label>Tree Type</label>
            <select id="treeType" onchange="changeTreeType()">
                <option value="BST">Binary Search Tree (BST)</option>
                <option value="AVL">AVL Tree (Self-Balancing)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Operations</label>
            <input type="number" id="nodeValue" placeholder="Enter integer value..." onkeypress="handleEnter(event)">
            <div class="btn-grid">
                <button onclick="performInsert()">Insert</button>
                <button class="danger" onclick="performDelete()">Delete</button>
            </div>
            <div class="btn-grid" style="margin-top: 8px;">
                <button class="secondary" onclick="performSearch()">Search</button>
                <button class="secondary" onclick="resetTree()">Clear All</button>
            </div>
        </div>

        <div class="control-group">
            <label>Analysis & Traversals</label>
            <div class="btn-grid">
                <button class="secondary" onclick="findMinMax('min')">Find Min</button>
                <button class="secondary" onclick="findMinMax('max')">Find Max</button>
            </div>
            <div class="btn-grid" style="margin-top: 8px;">
                <button class="secondary" onclick="performTraversal('inorder')">In-Order</button>
                <button class="secondary" onclick="performTraversal('levelorder')">Level-Order</button>
            </div>
            <div class="btn-grid" style="margin-top: 6px;">
                <button class="secondary" onclick="performTraversal('preorder')">Pre-Order</button>
                <button class="secondary" onclick="performTraversal('postorder')">Post-Order</button>
            </div>
        </div>
        
        <button class="secondary btn-full" onclick="generateRandomTree()">Generate Random Tree</button>

        <div id="status-log">Ready. Select a Tree Type and start operations.</div>
        
        <div class="legend">
            <div class="legend-item"><div class="dot" style="background:#4facfe"></div>Node</div>
            <div class="legend-item"><div class="dot" style="background:#ffeb3b"></div>Scan</div>
            <div class="legend-item"><div class="dot" style="background:#ff416c"></div>Found</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let rootNode = null;
        let font = null;
        let isAnimating = false;
        let treeType = "BST"; 
        let lastOperationLog = "Tree initialized.";
        const apiKey = ""; // Injected by environment
        
        // Visual Constants
        const NODE_RADIUS = 1.6;
        const LEVEL_HEIGHT = 5.0;
        const SPHERE_SEGMENTS = 32;
        const INITIAL_SPREAD = 35;
        
        // Colors
        const COLOR_DEFAULT = 0x4facfe;
        const COLOR_ACTIVE = 0xffeb3b;
        const COLOR_VISITED = 0x4caf50;
        const COLOR_FOUND = 0xff416c;
        const COLOR_EDGE = 0xffffff;
        const COLOR_TEXT = 0xffffff;

        // Tree Logic
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.mesh = null;
                this.textMesh = null;
                this.lineParent = null;
            }
        }

        // --- Initialization ---
        init();

        function init() {
            const container = document.getElementById('canvas-container');
            
            // Scene: Dark Mode
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); 
            scene.fog = new THREE.Fog(0x050510, 40, 150);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- Dark Mode Lighting ---
            // Removed shadow plane as it's not visible on black background
            // and we want floating objects

            // Soft Ambient for base visibility
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            // Key Light
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(20, 30, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // Fill Light (Cool Blue)
            const fillLight = new THREE.DirectionalLight(0x4facfe, 0.5);
            fillLight.position.set(-20, 10, 20);
            scene.add(fillLight);

            // Rim Light (Strong Backlight for edge definition)
            const rimLight = new THREE.DirectionalLight(0xffffff, 2.0);
            rimLight.position.set(0, 10, -50); 
            scene.add(rimLight);

            const loader = new FontLoader();
            loader.load(
                'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', 
                function (loadedFont) {
                    font = loadedFont;
                    if (rootNode) {
                        clearSceneTree(); 
                        renderTree(rootNode); 
                    }
                },
                undefined,
                function (err) { console.warn("Font error", err); }
            );

            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            
            animate();
            setTimeout(() => window.generateRandomTree(), 100);
            window.addEventListener('resize', onWindowResize);
        }

        // --- GEMINI AI INTEGRATION ---

        async function callGemini(prompt, systemInstruction = "") {
            const model = "gemini-2.5-flash-preview-09-2025";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
            } catch (error) {
                console.error("Gemini Error:", error);
                return "Error connecting to AI.";
            }
        }

        window.runAISimulation = async () => {
            if(isAnimating) return;
            const prompt = document.getElementById('ai-prompt').value;
            if(!prompt.trim()) return log("Please enter an AI prompt.");

            const btn = document.getElementById('btn-simulate');
            const originalText = btn.innerText;
            btn.innerText = "Thinking...";
            btn.classList.add("loading-spinner");
            
            log("AI is planning simulation...");
            const aiLog = document.getElementById('ai-log');
            aiLog.style.display = 'block';
            aiLog.innerText = "Analyzing request...";

            const systemPrompt = `You are a DSA simulation parser. 
            User Request: "${prompt}"
            Current Tree Type: ${treeType}
            
            Analyze the request and output a JSON Array of operations.
            Supported operations: 
            - { "op": "insert", "val": number }
            - { "op": "delete", "val": number }
            - { "op": "search", "val": number }
            - { "op": "clear" }
            - { "op": "traversal", "type": "inorder" | "preorder" | "postorder" | "levelorder" }
            
            If the user asks for random numbers (e.g. "insert 5 random nodes"), generate explicit numbers yourself.
            Output ONLY the JSON array. No markdown, no text.`;

            try {
                const result = await callGemini(prompt, systemPrompt);
                let cleanResult = result.replace(/```json/g, '').replace(/```/g, '').trim();
                const operations = JSON.parse(cleanResult);

                aiLog.innerText = `Plan: ${operations.length} steps. Executing...`;
                btn.innerText = "Simulating...";

                for (const cmd of operations) {
                    if (cmd.op === 'insert') await window.performInsert(cmd.val);
                    else if (cmd.op === 'delete') await window.performDelete(cmd.val);
                    else if (cmd.op === 'search') await window.performSearch(cmd.val);
                    else if (cmd.op === 'clear') window.resetTree();
                    else if (cmd.op === 'traversal') await window.performTraversal(cmd.type);
                    await sleep(500); // Pause between ops
                }
                
                aiLog.innerText += "\nSimulation Complete.";
                log("AI Simulation Finished.");
            } catch (e) {
                aiLog.innerText = "Failed to parse AI plan. Try simpler commands.";
                console.error(e);
            } finally {
                btn.innerText = originalText;
                btn.classList.remove("loading-spinner");
            }
        };

        window.explainState = async () => {
            const btn = document.getElementById('btn-explain');
            const originalText = btn.innerText;
            btn.innerText = "Analyzing...";
            btn.classList.add("loading-spinner");

            const aiLog = document.getElementById('ai-log');
            aiLog.style.display = 'block';
            aiLog.innerText = "Generating explanation...";

            // Serialize simplified tree structure
            const serialize = (n) => {
                if(!n) return null;
                return { v: n.value, h: n.height, l: serialize(n.left), r: serialize(n.right) };
            };
            const treeData = JSON.stringify(serialize(rootNode));

            const systemPrompt = `You are a Data Structures Professor.
            The user is visualizing a ${treeType}.
            Last Operation Log: "${lastOperationLog}"
            
            Current Tree Structure (JSON): ${treeData.substring(0, 2000)}... (truncated if long)
            
            Explain briefly (max 3 sentences) what happened in the last step and the current state of the tree. 
            Mention any rebalancing (rotations) if it's an AVL tree, or BST properties enforced.`;

            try {
                const explanation = await callGemini("Explain the current state.", systemPrompt);
                aiLog.innerText = explanation;
            } catch (e) {
                aiLog.innerText = "Error getting explanation.";
            } finally {
                btn.innerText = originalText;
                btn.classList.remove("loading-spinner");
            }
        };


        // --- TREE LOGIC (BST & AVL) ---

        function getHeight(node) { return node ? node.height : 0; }
        function getBalance(node) { return node ? getHeight(node.left) - getHeight(node.right) : 0; }

        function rightRotate(y) {
            let x = y.left; let T2 = x.right;
            x.right = y; y.left = T2;
            y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
            x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
            return x;
        }

        function leftRotate(x) {
            let y = x.right; let T2 = y.left;
            y.left = x; x.right = T2;
            x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
            y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
            return y;
        }

        function insertAVL(node, value) {
            if (!node) return new TreeNode(value);
            if (value < node.value) node.left = insertAVL(node.left, value);
            else if (value > node.value) node.right = insertAVL(node.right, value);
            else return node;

            node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
            let balance = getBalance(node);

            if (balance > 1 && value < node.left.value) return rightRotate(node);
            if (balance < -1 && value > node.right.value) return leftRotate(node);
            if (balance > 1 && value > node.left.value) { node.left = leftRotate(node.left); return rightRotate(node); }
            if (balance < -1 && value < node.right.value) { node.right = rightRotate(node.right); return leftRotate(node); }
            return node;
        }

        function insertBST(node, value) {
            if (!node) return new TreeNode(value);
            if (value < node.value) node.left = insertBST(node.left, value);
            else if (value > node.value) node.right = insertBST(node.right, value);
            return node;
        }

        function minValueNode(node) {
            let current = node; while (current.left !== null) current = current.left; return current;
        }

        function deleteNode(root, value, type) {
            if (!root) return root;
            if (value < root.value) root.left = deleteNode(root.left, value, type);
            else if (value > root.value) root.right = deleteNode(root.right, value, type);
            else {
                if (!root.left || !root.right) {
                    let temp = root.left ? root.left : root.right;
                    if (!temp) { temp = root; root = null; } else root = temp;
                } else {
                    let temp = minValueNode(root.right);
                    root.value = temp.value;
                    root.right = deleteNode(root.right, temp.value, type);
                }
            }
            if (!root) return root;

            if (type === 'AVL') {
                root.height = 1 + Math.max(getHeight(root.left), getHeight(root.right));
                let balance = getBalance(root);
                if (balance > 1 && getBalance(root.left) >= 0) return rightRotate(root);
                if (balance > 1 && getBalance(root.left) < 0) { root.left = leftRotate(root.left); return rightRotate(root); }
                if (balance < -1 && getBalance(root.right) <= 0) return leftRotate(root);
                if (balance < -1 && getBalance(root.right) > 0) { root.right = rightRotate(root.right); return leftRotate(root); }
            }
            return root;
        }

        function updatePositions(node, depth = 0, x = 0, range = INITIAL_SPREAD) {
            if (!node) return;
            node.y = 10 - (depth * LEVEL_HEIGHT);
            node.x = x;
            let nextRange = range / 2;
            if (nextRange < 2.5) nextRange = 2.5;
            updatePositions(node.left, depth + 1, x - nextRange, nextRange);
            updatePositions(node.right, depth + 1, x + nextRange, nextRange);
        }

        function countNodes(node) {
            if (!node) return 0; return 1 + countNodes(node.left) + countNodes(node.right);
        }

        function getTreeHeight(node) {
            if (!node) return 0; return 1 + Math.max(getTreeHeight(node.left), getTreeHeight(node.right));
        }

        function clearSceneTree() {
            const removeObj = (node) => {
                if (!node) return;
                if (node.mesh) { scene.remove(node.mesh); node.mesh.geometry.dispose(); node.mesh.material.dispose(); node.mesh = null; }
                if (node.textMesh) { scene.remove(node.textMesh); node.textMesh.geometry.dispose(); node.textMesh.material.dispose(); node.textMesh = null; }
                if (node.lineParent) { scene.remove(node.lineParent); node.lineParent.geometry.dispose(); node.lineParent.material.dispose(); node.lineParent = null; }
                removeObj(node.left); removeObj(node.right);
            };
            removeObj(rootNode);
        }

        function renderTree(node, parent = null) {
            if (!node) return;
            if (!node.mesh) {
                const geometry = new THREE.SphereGeometry(NODE_RADIUS, SPHERE_SEGMENTS, SPHERE_SEGMENTS);
                const material = new THREE.MeshPhysicalMaterial({ color: COLOR_DEFAULT, metalness: 0.3, roughness: 0.1, clearcoat: 0.8, clearcoatRoughness: 0.2 });
                node.mesh = new THREE.Mesh(geometry, material);
                node.mesh.castShadow = true; node.mesh.receiveShadow = true;
                if (font) {
                    const textGeo = new TextGeometry(String(node.value), { font: font, size: 0.7, height: 0.05 });
                    textGeo.center();
                    node.textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: COLOR_TEXT }));
                    scene.add(node.textMesh);
                }
                scene.add(node.mesh);
            }
            const targetPos = new THREE.Vector3(node.x, node.y, 0);
            node.mesh.position.lerp(targetPos, 1);
            if (node.textMesh) node.textMesh.position.set(node.x, node.y, NODE_RADIUS + 0.1);

            if (parent) {
                if (node.lineParent) scene.remove(node.lineParent);
                const start = new THREE.Vector3(parent.x, parent.y, 0);
                const end = new THREE.Vector3(node.x, node.y, 0);
                const dir = new THREE.Vector3().subVectors(end, start).normalize();
                const startAdj = start.clone().add(dir.clone().multiplyScalar(NODE_RADIUS));
                const endAdj = end.clone().sub(dir.clone().multiplyScalar(NODE_RADIUS));
                const tubeGeo = new THREE.TubeGeometry(new THREE.LineCurve3(startAdj, endAdj), 4, 0.1, 8, false);
                node.lineParent = new THREE.Mesh(tubeGeo, new THREE.MeshBasicMaterial({ color: COLOR_EDGE, transparent: true, opacity: 0.5 }));
                scene.add(node.lineParent);
            }
            renderTree(node.left, node); renderTree(node.right, node);
        }

        function updateStats() {
            document.getElementById('stat-height').innerText = getTreeHeight(rootNode);
            document.getElementById('stat-nodes').innerText = countNodes(rootNode);
        }

        function highlightNode(node, color) {
            if (node && node.mesh) {
                node.mesh.material.color.setHex(color);
                node.mesh.scale.set(color === COLOR_ACTIVE || color === COLOR_FOUND ? 1.2 : 1, color === COLOR_ACTIVE || color === COLOR_FOUND ? 1.2 : 1, color === COLOR_ACTIVE || color === COLOR_FOUND ? 1.2 : 1);
            }
        }

        function resetColors(node) {
            if (!node) return; highlightNode(node, COLOR_DEFAULT); resetColors(node.left); resetColors(node.right);
        }

        const sleep = ms => new Promise(r => setTimeout(r, ms));

        // --- Interaction Functions (Updated for AI) ---

        window.changeTreeType = () => {
            treeType = document.getElementById('treeType').value;
            window.resetTree();
            log(`Switched to ${treeType}. Tree cleared.`);
        };

        window.performInsert = async (valOverride = null) => {
            if (isAnimating) return;
            
            let val;
            if (valOverride !== null) val = parseInt(valOverride);
            else val = parseInt(document.getElementById('nodeValue').value);
            
            if (isNaN(val)) return log("Invalid number");

            isAnimating = true;
            controls.autoRotate = false;
            log(`Inserting ${val}...`);
            
            let curr = rootNode;
            while (curr) {
                highlightNode(curr, COLOR_ACTIVE);
                await sleep(300);
                highlightNode(curr, COLOR_VISITED);
                if (val < curr.value) curr = curr.left;
                else if (val > curr.value) curr = curr.right;
                else break;
            }

            clearSceneTree();
            if (treeType === 'BST') rootNode = insertBST(rootNode, val);
            else rootNode = insertAVL(rootNode, val);
            
            lastOperationLog = `Inserted ${val} into ${treeType}.`;
            updatePositions(rootNode);
            renderTree(rootNode);
            updateStats();
            
            if(valOverride === null) {
                document.getElementById('nodeValue').value = '';
                document.getElementById('nodeValue').focus();
            }
            
            await sleep(500);
            resetColors(rootNode);
            isAnimating = false;
        };

        window.performDelete = async (valOverride = null) => {
            if (isAnimating) return;
            
            let val;
            if (valOverride !== null) val = parseInt(valOverride);
            else val = parseInt(document.getElementById('nodeValue').value);

            if (isNaN(val)) return log("Invalid number");

            log(`Deleting ${val}...`);
            clearSceneTree();
            rootNode = deleteNode(rootNode, val, treeType);
            lastOperationLog = `Deleted ${val} from ${treeType}.`;
            updatePositions(rootNode);
            renderTree(rootNode);
            updateStats();
            log(`Deleted ${val}.`);
        };

        window.performSearch = async (valOverride = null) => {
            if (isAnimating) return;
            
            let val;
            if (valOverride !== null) val = parseInt(valOverride);
            else val = parseInt(document.getElementById('nodeValue').value);

            if (isNaN(val)) return log("Invalid number");

            isAnimating = true;
            controls.autoRotate = false;
            resetColors(rootNode);
            log(`Searching for ${val}...`);
            
            let curr = rootNode;
            let found = false;
            while(curr) {
                highlightNode(curr, COLOR_ACTIVE);
                await sleep(400);
                if (curr.value === val) {
                    found = true;
                    highlightNode(curr, COLOR_FOUND);
                    log(`Found ${val}!`);
                    break;
                }
                highlightNode(curr, COLOR_VISITED);
                curr = val < curr.value ? curr.left : curr.right;
            }
            if(!found) log("Value not found.");
            
            lastOperationLog = `Searched for ${val}. Found: ${found}`;
            await sleep(1000);
            resetColors(rootNode);
            isAnimating = false;
        };

        window.findMinMax = async (type) => {
            if (isAnimating || !rootNode) return;
            isAnimating = true;
            controls.autoRotate = false;
            resetColors(rootNode);
            log(`Finding ${type}...`);
            
            let curr = rootNode;
            while(curr) {
                highlightNode(curr, COLOR_ACTIVE);
                await sleep(400);
                if (type === 'min') {
                    if (!curr.left) break; highlightNode(curr, COLOR_VISITED); curr = curr.left;
                } else {
                    if (!curr.right) break; highlightNode(curr, COLOR_VISITED); curr = curr.right;
                }
            }
            highlightNode(curr, COLOR_FOUND);
            log(`${type === 'min' ? 'Min' : 'Max'} is ${curr.value}`);
            lastOperationLog = `Found ${type} value: ${curr.value}`;
            await sleep(1500);
            resetColors(rootNode);
            isAnimating = false;
        };

        window.performTraversal = async (type) => {
            if (isAnimating) return;
            isAnimating = true;
            controls.autoRotate = false;
            resetColors(rootNode);
            log(`Starting ${type} traversal...`);
            
            let result = [];
            if (type === 'inorder') traverseInOrder(rootNode, result);
            else if (type === 'preorder') traversePreOrder(rootNode, result);
            else if (type === 'postorder') traversePostOrder(rootNode, result);
            else if (type === 'levelorder') traverseLevelOrder(rootNode, result);
            
            let str = "";
            for (let n of result) {
                highlightNode(n, COLOR_ACTIVE);
                str += n.value + " ";
                await sleep(500);
                highlightNode(n, COLOR_VISITED);
            }
            log(`${type}: ${str}`);
            lastOperationLog = `Performed ${type} traversal.`;
            await sleep(1000);
            resetColors(rootNode);
            isAnimating = false;
        };

        function traverseInOrder(node, res) { if(!node)return; traverseInOrder(node.left, res); res.push(node); traverseInOrder(node.right, res); }
        function traversePreOrder(node, res) { if(!node)return; res.push(node); traversePreOrder(node.left, res); traversePreOrder(node.right, res); }
        function traversePostOrder(node, res) { if(!node)return; traversePostOrder(node.left, res); traversePostOrder(node.right, res); res.push(node); }
        function traverseLevelOrder(node, res) { if(!node)return; let q=[node]; while(q.length){ let n=q.shift(); res.push(n); if(n.left)q.push(n.left); if(n.right)q.push(n.right); } }

        window.resetTree = () => { clearSceneTree(); rootNode = null; updateStats(); log("Tree cleared."); lastOperationLog = "Tree cleared."; };

        window.generateRandomTree = () => {
            window.resetTree();
            let count = 15;
            log(`Generating random ${treeType}...`);
            let nums = new Set();
            while(nums.size < count) nums.add(Math.floor(Math.random() * 100) + 1);
            nums.forEach(val => { if(treeType === 'BST') rootNode = insertBST(rootNode, val); else rootNode = insertAVL(rootNode, val); });
            updatePositions(rootNode); renderTree(rootNode); updateStats();
            lastOperationLog = "Generated random tree.";
        };

        window.handleEnter = (e) => { if (e.key === 'Enter') performInsert(); };

        function log(msg) {
            const el = document.getElementById('status-log');
            el.innerHTML = `<div>> ${msg}</div>` + el.innerHTML;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.toggleUI = () => {
            const panel = document.getElementById('ui-panel');
            const btn = document.getElementById('ui-toggle-btn');
            if (panel.style.opacity === '0') {
                panel.style.opacity = '1'; panel.style.pointerEvents = 'all'; panel.style.transform = 'translateY(0)';
                btn.innerHTML = '<span>üëÅÔ∏è</span> Toggle Controls'; btn.style.opacity = '1';
            } else {
                panel.style.opacity = '0'; panel.style.pointerEvents = 'none'; panel.style.transform = 'translateY(-10px)';
                btn.innerHTML = '<span>üëÅÔ∏è</span> Show Controls'; btn.style.opacity = '0.7';
            }
        };
    </script>
</body>
</html>
