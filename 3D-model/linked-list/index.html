<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Linked List Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #050505;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Let clicks pass through to canvas where needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Top Bar: List Type Selection */
        .top-bar {
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .type-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: #aaa;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        .type-btn.active {
            background: #4f46e5;
            border-color: #4f46e5;
            color: white;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }

        .type-btn:hover:not(.active) {
            border-color: white;
            color: white;
        }

        /* Bottom Control Panel */
        .controls-container {
            pointer-events: auto;
            position: absolute;
            top: 80px;
            left: 20px;
            width: 280px; /* Fixed smaller width */
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

        input[type="number"] {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px;
            border-radius: 6px;
            width: 50px;
            text-align: center;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
        }

        button.action-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 0.8rem;
            flex-grow: 1;
            text-align: center;
        }

        button.action-btn:hover {
            background: #3b82f6;
            transform: translateY(-2px);
        }

        button.action-btn.danger { background: #dc2626; }
        button.action-btn.danger:hover { background: #ef4444; }
        
        button.action-btn.warning { background: #d97706; }
        button.action-btn.warning:hover { background: #f59e0b; }

        /* Gemini AI Section */
        .ai-section {
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 10px;
            padding-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .ai-label {
            color: #c084fc; /* Purple */
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .ai-input {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(192, 132, 252, 0.3);
            color: #e9d5ff;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            resize: vertical;
            min-height: 60px;
        }
        .ai-input:focus {
            outline: none;
            border-color: #c084fc;
        }

        .ai-btn {
            background: linear-gradient(135deg, #9333ea, #7c3aed);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85rem;
            box-shadow: 0 4px 10px rgba(124, 58, 237, 0.3);
            transition: all 0.2s;
        }
        .ai-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 15px rgba(124, 58, 237, 0.4);
        }
        
        .ai-btn.secondary {
            background: rgba(124, 58, 237, 0.1);
            border: 1px solid rgba(124, 58, 237, 0.5);
            color: #d8b4fe;
        }
        .ai-btn.secondary:hover {
            background: rgba(124, 58, 237, 0.2);
        }

        #ai-explanation {
            font-size: 0.85rem;
            color: #d8b4fe;
            background: rgba(88, 28, 135, 0.2);
            padding: 10px;
            border-radius: 8px;
            border-left: 2px solid #c084fc;
            display: none; /* Hidden by default */
            margin-top: 5px;
            line-height: 1.4;
        }

        /* Algorithm Log/Explanation */
        .algo-log {
            pointer-events: auto;
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 0.9rem;
            color: #ddd;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .algo-log h3 {
            margin-top: 0;
            color: #4f46e5;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }

        .log-entry {
            margin-bottom: 8px;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
            border-left: 2px solid #4f46e5;
            padding-left: 8px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* 3D Labels */
        .label {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            user-select: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .tutorial-hint {
            position: absolute;
            bottom: 20px; /* Moved to bottom */
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            pointer-events: none;
            font-size: 0.85rem;
            user-select: none;
        }

        /* Show Button (Initially Hidden) */
        #show-controls-btn {
            position: absolute;
            top: 80px;
            left: 20px;
            pointer-events: auto;
            display: none;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        #show-controls-btn:hover {
            background: #3b82f6;
            transform: translateY(-2px);
        }
        
        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <button class="type-btn active" onclick="switchMode('singly')">Singly Linked</button>
            <button class="type-btn" onclick="switchMode('doubly')">Doubly Linked</button>
            <button class="type-btn" onclick="switchMode('circular')">Circular Linked</button>
        </div>

        <div class="algo-log">
            <h3>Operation Log</h3>
            <div id="log-content">
                <div class="log-entry">Welcome! Select a list type and perform operations.</div>
            </div>
        </div>

        <div class="tutorial-hint">Drag to Rotate • Scroll to Zoom • Right Click to Pan</div>

        <!-- Show Controls Button -->
        <button id="show-controls-btn" onclick="toggleControls()">Show Controls</button>

        <div class="controls-container" id="controls-panel">
            <!-- Hide Header -->
            <div style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:5px;">
                <span style="font-weight:600; color:#4f46e5; font-size:0.9rem;">Operations</span>
                <button onclick="toggleControls()" style="background:transparent; border:none; color:#aaa; cursor:pointer; font-size:1.2rem; line-height:1;">×</button>
            </div>
            
            <div class="controls-row">
                <input type="number" id="data-input" placeholder="Value" value="10">
                <button class="action-btn" onclick="handleInsert('head')">Insert Head</button>
                <button class="action-btn" onclick="handleInsert('tail')">Insert Tail</button>
                <input type="number" id="index-input" placeholder="Index" value="1" style="width: 60px;">
                <button class="action-btn" onclick="handleInsert('index')">Insert at Index</button>
            </div>
            <div class="controls-row">
                <button class="action-btn danger" onclick="handleDelete('head')">Delete Head</button>
                <button class="action-btn danger" onclick="handleDelete('tail')">Delete Tail</button>
                <button class="action-btn danger" onclick="handleDelete('index')">Delete Index</button>
            </div>
            <div class="controls-row">
                <input type="number" id="search-input" placeholder="Val" value="10" style="width: 60px;">
                <button class="action-btn warning" onclick="handleSearch()">Search</button>
                <button class="action-btn warning" onclick="handleReverse()">Reverse List</button>
            </div>

            <!-- Gemini AI Section -->
            <div class="ai-section">
                <div class="ai-label">Gemini AI Assistant</div>
                <textarea id="ai-prompt" class="ai-input" placeholder="e.g. 'Insert 10, 20, 30 then delete head' or 'Find 15'"></textarea>
                <div style="display:flex; gap:8px;">
                    <button class="ai-btn" style="flex:1;" onclick="handleAutoSimulate()">Auto Simulate</button>
                    <button class="ai-btn secondary" style="flex:1;" onclick="handleExplainState()">Explain State</button>
                </div>
                <div id="ai-explanation"></div>
            </div>
        </div>
    </div>

    <!-- Three.js Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tweening Library for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // --- Configuration & Global State ---
        const CONFIG = {
            nodeSpacing: 4.5,
            nodeSize: 1.5, // Cube width/height/depth
            colors: {
                node: 0x4f46e5,
                nodeHighlight: 0xf43f5e, // Red/Pink for active
                nodeFound: 0x10b981,     // Green for found
                link: 0xffffff,
                text: 'white'
            }
        };

        const apiKey = ""; // API Key injected by environment
        let currentMode = 'singly'; // singly, doubly, circular
        let nodes = []; // Array of Node objects
        let isAnimating = false;

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        // Add some fog for depth - darker to blend with floor
        scene.fog = new THREE.FogExp2(0x050505, 0.012);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 20); // Lift camera slightly to see the grid perspective

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent going below floor

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001; // Fix shadow artifacts
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // Backlight for 3D definition (Rim light)
        const backLight = new THREE.DirectionalLight(0x6366f1, 0.5);
        backLight.position.set(-10, 5, -20);
        scene.add(backLight);

        const pointLight = new THREE.PointLight(0x4f46e5, 0.8, 20);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // --- Grid & Environment ---
        const environmentGroup = new THREE.Group();
        scene.add(environmentGroup);

        // 1. Primary Grid (Major lines)
        const gridHelper = new THREE.GridHelper(300, 30, 0x4f46e5, 0x000000);
        gridHelper.position.y = -2.5;
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        environmentGroup.add(gridHelper);

        // 2. Secondary Grid (Fine lines)
        const subGridHelper = new THREE.GridHelper(300, 150, 0x333333, 0x000000);
        subGridHelper.position.y = -2.5;
        subGridHelper.material.opacity = 0.15;
        subGridHelper.material.transparent = true;
        environmentGroup.add(subGridHelper);

        // Dark Floor for Shadows
        const planeGeo = new THREE.PlaneGeometry(2000, 2000);
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x080808, 
            roughness: 0.5,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(planeGeo, planeMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -2.51; // Just below grid
        floor.receiveShadow = true;
        environmentGroup.add(floor);

        // Group to hold all list elements
        const listGroup = new THREE.Group();
        scene.add(listGroup);

        // --- Helpers ---
        
        // Create Text Texture for Node (SQUARE for Cube)
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Fill Background (Square)
            ctx.fillStyle = '#4f46e5'; 
            ctx.fillRect(0,0, 256, 256);
            
            // Inner Border
            ctx.strokeStyle = '#a5b4fc';
            ctx.lineWidth = 15;
            ctx.strokeRect(10, 10, 236, 236);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 110px Inter, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128);

            // Add a little shine detail
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.lineTo(256,0);
            ctx.lineTo(0, 256);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Helper: Create Texture for Index Badge
        function createIndexTexture(index) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Badge Background (Circle)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(32, 32, 30, 0, Math.PI*2);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#fbbf24'; // Gold color
            ctx.lineWidth = 3;
            ctx.stroke();

            // Text
            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 30px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(index, 32, 34);

            return new THREE.CanvasTexture(canvas);
        }

        // --- Node Class ---
        class ListNode {
            constructor(value) {
                this.value = value;
                this.uuid = THREE.MathUtils.generateUUID(); // Unique ID for finding in scene
                
                // Visual Mesh - CUBE
                const geometry = new THREE.BoxGeometry(CONFIG.nodeSize, CONFIG.nodeSize, CONFIG.nodeSize);
                const material = new THREE.MeshStandardMaterial({ 
                    map: createTextTexture(value),
                    color: 0xffffff,
                    roughness: 0.2, // Shinier
                    metalness: 0.1
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.userData = { id: this.uuid, value: value };
                
                // Glow effect (Outer Cube)
                const glowGeo = new THREE.BoxGeometry(CONFIG.nodeSize + 0.2, CONFIG.nodeSize + 0.2, CONFIG.nodeSize + 0.2);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: CONFIG.colors.node, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);
                this.mesh.add(this.glow);

                // Index Badge (Floating Sprite)
                this.indexSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: null, transparent: true }));
                this.indexSprite.position.set(0, 1.3, 0); // Float above cube
                this.indexSprite.scale.set(0.8, 0.8, 0.8);
                this.mesh.add(this.indexSprite);
                this.currentIndex = -1; // Track index to avoid needless updates

                // Arrows (Connections) - Stored visually
                this.arrowNext = null;
                this.arrowPrev = null; 
            }

            updateIndex(newIndex) {
                if (this.currentIndex === newIndex) return;
                this.currentIndex = newIndex;
                
                if (this.indexSprite.material.map) {
                    this.indexSprite.material.map.dispose();
                }
                this.indexSprite.material.map = createIndexTexture(newIndex);
            }

            setPosition(x, y, z) {
                this.mesh.position.set(x, y, z);
            }

            highlight(colorHex) {
                // Change emissive color for highlight
                new TWEEN.Tween(this.mesh.material)
                    .to({ emissive: new THREE.Color(colorHex), emissiveIntensity: 0.8 }, 300)
                    .start();
                
                // Pulse the glow
                new TWEEN.Tween(this.glow.scale)
                    .to({ x: 1.2, y: 1.2, z: 1.2 }, 300)
                    .yoyo(true)
                    .repeat(1)
                    .start();
                
                // Pulse the glow color
                this.glow.material.color.setHex(colorHex);
            }

            resetColor() {
                new TWEEN.Tween(this.mesh.material)
                    .to({ emissive: new THREE.Color(0x000000), emissiveIntensity: 0 }, 300)
                    .start();
                this.glow.material.color.setHex(CONFIG.colors.node);
            }
        }

        // --- Logic & Rendering ---

        function clearScene() {
            while(listGroup.children.length > 0){ 
                listGroup.remove(listGroup.children[0]); 
            }
            nodes = [];
        }

        function createArrow(start, end, color = 0xffffff, curve = false) {
            const dir = new THREE.Vector3().subVectors(end, start);
            const length = dir.length();
            
            if (length < 0.1) return null; 

            if (curve) {
                // For Circular link (Tail -> Head) - Big Arc
                const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                mid.y += 5; // Height of curve
                mid.z += 3; // Depth of curve to avoid hitting nodes

                const curvePath = new THREE.QuadraticBezierCurve3(start, mid, end);
                const points = curvePath.getPoints(30);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
                const curveObject = new THREE.Line(geometry, material);
                
                // Cone at the end
                const tangent = curvePath.getTangent(1).normalize();
                const coneGeo = new THREE.ConeGeometry(0.25, 0.7, 16);
                const coneMat = new THREE.MeshBasicMaterial({ color: color });
                const cone = new THREE.Mesh(coneGeo, coneMat);
                
                const conePos = end.clone().sub(tangent.multiplyScalar(CONFIG.nodeSize/2 + 0.5));
                cone.position.copy(conePos);
                cone.lookAt(cone.position.clone().add(tangent));
                
                const group = new THREE.Group();
                group.add(curveObject);
                group.add(cone);
                return group;

            } else {
                // Straight Arrow
                // Offset calculation for CUBE faces
                const halfSize = CONFIG.nodeSize / 2;
                const offsetVec = dir.clone().normalize().multiplyScalar(halfSize);
                
                const adjustedStart = start.clone().add(offsetVec);
                const adjustedEnd = end.clone().sub(offsetVec);
                
                const arrowLength = adjustedStart.distanceTo(adjustedEnd);
                
                // We use ArrowHelper but with specific params
                const arrowHelper = new THREE.ArrowHelper(
                    dir.normalize(), 
                    adjustedStart, 
                    arrowLength, 
                    color, 
                    0.6, // head length
                    0.3  // head width
                );
                return arrowHelper;
            }
        }

        // Helper for Single Node Circular Loop
        function createSelfLoop(position) {
            const radius = 1.5;
            const curvePath = new THREE.CubicBezierCurve3(
                new THREE.Vector3(position.x + 0.5, position.y, position.z + 0.5),
                new THREE.Vector3(position.x + 2, position.y, position.z + 2),
                new THREE.Vector3(position.x - 2, position.y, position.z + 2),
                new THREE.Vector3(position.x - 0.5, position.y, position.z + 0.5)
            );
            
            const points = curvePath.getPoints(30);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: CONFIG.colors.link, linewidth: 2 });
            const loopLine = new THREE.Line(geometry, material);

            const coneGeo = new THREE.ConeGeometry(0.25, 0.7, 16);
            const coneMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.link });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            
            // Position cone at end of loop
            const endPoint = points[points.length-1];
            const tangent = curvePath.getTangent(1).normalize();
            cone.position.copy(endPoint);
            cone.lookAt(endPoint.clone().add(tangent));

            const group = new THREE.Group();
            group.add(loopLine);
            group.add(cone);
            return group;
        }

        function renderList() {
            // Mark old arrows for removal
            listGroup.children.forEach(child => {
                if (child.type === 'ArrowHelper' || child.type === 'Group' || child.type === 'Line') {
                    child.userData.toBeRemoved = true;
                }
            });
            // Filter out marked items
            listGroup.children = listGroup.children.filter(c => !c.userData.toBeRemoved);

            if (currentMode === 'circular') {
                // --- CIRCULAR LAYOUT ---
                const count = nodes.length;
                // Calculate radius based on count to prevent overlapping
                // Minimum radius of 3, expands as count grows
                const radius = count > 1 ? Math.max(5, (count * CONFIG.nodeSpacing) / (2 * Math.PI)) : 0;

                nodes.forEach((node, i) => {
                    // Update Index Badge
                    node.updateIndex(i);

                    // Position in a ring
                    // Start angle -PI/2 to put index 0 at the "front/bottom"
                    const angle = (i / count) * Math.PI * 2 - (Math.PI / 2);
                    
                    const tx = count > 1 ? Math.cos(angle) * radius : 0;
                    const tz = count > 1 ? Math.sin(angle) * radius : 0;

                    new TWEEN.Tween(node.mesh.position)
                        .to({ x: tx, y: 0, z: tz }, 500)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    if (!listGroup.children.includes(node.mesh)) {
                        listGroup.add(node.mesh);
                        node.mesh.scale.set(0,0,0);
                        new TWEEN.Tween(node.mesh.scale).to({x:1, y:1, z:1}, 500).start();
                    }
                    
                    // Rotate cube to face outward (optional, looks cool)
                    new TWEEN.Tween(node.mesh.rotation)
                        .to({ y: -angle + Math.PI/2 }, 500)
                        .start();
                });

                // Delayed Arrow Drawing for Circle
                setTimeout(() => {
                    listGroup.children = listGroup.children.filter(c => 
                        c.type === 'Mesh' || (c.type === 'Group' && c.children[0]?.type === 'Mesh')
                    );

                    for (let i = 0; i < count; i++) {
                        // Logic: Point to next, wrap last to first
                        const startNode = nodes[i];
                        const endNode = nodes[(i + 1) % count]; 

                        if (count > 1) {
                            // Calculate exact positions based on layout logic to ensure clean lines
                            // (Using current mesh position might be mid-tween if we are fast)
                            const angle1 = (i / count) * Math.PI * 2 - (Math.PI / 2);
                            const angle2 = (((i + 1) % count) / count) * Math.PI * 2 - (Math.PI / 2);
                            
                            const p1 = new THREE.Vector3(Math.cos(angle1) * radius, 0, Math.sin(angle1) * radius);
                            const p2 = new THREE.Vector3(Math.cos(angle2) * radius, 0, Math.sin(angle2) * radius);
                            
                            // Straight arrows form the polygon edges
                            const arrow = createArrow(p1, p2, CONFIG.colors.link);
                            if(arrow) listGroup.add(arrow);
                        } else {
                            // Single Node points to itself
                            const loop = createSelfLoop(startNode.mesh.position);
                            if(loop) listGroup.add(loop);
                        }
                    }
                }, 500);

            } else {
                // --- LINEAR LAYOUT (Singly/Doubly) ---
                const totalWidth = (nodes.length - 1) * CONFIG.nodeSpacing;
                const startX = -totalWidth / 2;

                nodes.forEach((node, index) => {
                    // Update Index Badge
                    node.updateIndex(index);

                    const targetX = startX + (index * CONFIG.nodeSpacing);
                    
                    // Reset rotation from circular mode
                    new TWEEN.Tween(node.mesh.rotation).to({y: 0}, 500).start();

                    new TWEEN.Tween(node.mesh.position)
                        .to({ x: targetX, y: 0, z: 0 }, 500)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    if (!listGroup.children.includes(node.mesh)) {
                        listGroup.add(node.mesh);
                        node.mesh.scale.set(0,0,0);
                        new TWEEN.Tween(node.mesh.scale)
                            .to({x:1, y:1, z:1}, 500)
                            .easing(TWEEN.Easing.Elastic.Out)
                            .start();
                    }
                });

                // Draw Arrows Delayed
                setTimeout(() => {
                    listGroup.children = listGroup.children.filter(c => 
                        c.type === 'Mesh' || (c.type === 'Group' && c.children[0]?.type === 'Mesh')
                    );

                    for (let i = 0; i < nodes.length; i++) {
                        const curr = nodes[i];
                        const next = nodes[i + 1];

                        // Standard Next Pointers
                        if (next) {
                            const arrow = createArrow(
                                new THREE.Vector3(startX + i * CONFIG.nodeSpacing, 0, 0),
                                new THREE.Vector3(startX + (i+1) * CONFIG.nodeSpacing, 0, 0),
                                CONFIG.colors.link
                            );
                            if(arrow) listGroup.add(arrow);

                            // Doubly Linked: Prev Pointer (Offset Z)
                            if (currentMode === 'doubly') {
                                const p1 = new THREE.Vector3(startX + (i+1) * CONFIG.nodeSpacing, -0.6, 0.8);
                                const p2 = new THREE.Vector3(startX + i * CONFIG.nodeSpacing, -0.6, 0.8);
                                const arrowPrev = createArrow(p1, p2, 0xaaaaaa);
                                if(arrowPrev) listGroup.add(arrowPrev);
                            }
                        }
                    }
                }, 500); 
            }
        }

        // --- Log System ---
        function log(message) {
            const logContainer = document.getElementById('log-content');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logContainer.prepend(entry);
            if(logContainer.children.length > 8) logContainer.lastChild.remove();
        }

        // --- UI Toggles ---
        function toggleControls() {
            const panel = document.getElementById('controls-panel');
            const btn = document.getElementById('show-controls-btn');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'flex';
                btn.style.display = 'none';
            } else {
                panel.style.display = 'none';
                btn.style.display = 'block';
            }
        }

        // --- Operations (Refactored for AI) ---

        function switchMode(mode) {
            if(isAnimating) return;
            currentMode = mode;
            
            document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="switchMode('${mode}')"]`).classList.add('active');
            
            log(`Switched to ${mode.charAt(0).toUpperCase() + mode.slice(1)} Linked List.`);
            renderList();
        }

        async function handleInsert(location, valueOverride = null, indexOverride = null) {
            if(isAnimating) return;
            isAnimating = true;

            const val = valueOverride !== null ? valueOverride : (parseInt(document.getElementById('data-input').value) || Math.floor(Math.random() * 100));
            const newNode = new ListNode(val);
            const idxInput = document.getElementById('index-input');
            let index = 0;

            if (location === 'head') {
                index = 0;
                log(`Inserting ${val} at Head...`);
            } else if (location === 'tail') {
                index = nodes.length;
                log(`Inserting ${val} at Tail...`);
            } else {
                index = indexOverride !== null ? indexOverride : (parseInt(idxInput.value) || 0);
                if(index < 0) index = 0;
                if(index > nodes.length) index = nodes.length;
                log(`Inserting ${val} at Index ${index}...`);
            }

            if (nodes.length > 0 && location === 'index') {
                log("Traversing to position...");
                for(let i=0; i<index; i++) {
                    nodes[i].highlight(CONFIG.colors.nodeHighlight);
                    await new Promise(r => setTimeout(r, 300));
                    nodes[i].resetColor();
                }
            }

            nodes.splice(index, 0, newNode);
            renderList();
            
            await new Promise(r => setTimeout(r, 1000));
            isAnimating = false;
        }

        async function handleDelete(location, indexOverride = null) {
            if(isAnimating || nodes.length === 0) {
                if(nodes.length === 0) log("List is empty!");
                return;
            }
            isAnimating = true;

            let index = 0;
            if (location === 'head') index = 0;
            else if (location === 'tail') index = nodes.length - 1;
            else {
                index = indexOverride !== null ? indexOverride : (parseInt(document.getElementById('index-input').value) || 0);
            }

            if(index < 0 || index >= nodes.length) {
                log("Index out of bounds");
                isAnimating = false;
                return;
            }

            log(`Deleting node at index ${index}...`);

            const targetNode = nodes[index];
            targetNode.highlight(0xff0000); 

            await new Promise(r => setTimeout(r, 600));

            new TWEEN.Tween(targetNode.mesh.scale)
                .to({x:0, y:0, z:0}, 400)
                .easing(TWEEN.Easing.Back.In)
                .start();

            await new Promise(r => setTimeout(r, 400));
            
            listGroup.remove(targetNode.mesh);
            nodes.splice(index, 1);
            
            renderList();
            
            await new Promise(r => setTimeout(r, 600));
            isAnimating = false;
        }

        async function handleSearch(valueOverride = null) {
            if(isAnimating || nodes.length === 0) return;
            isAnimating = true;

            const val = valueOverride !== null ? valueOverride : parseInt(document.getElementById('search-input').value);
            log(`Searching for value ${val}...`);

            let found = false;
            for(let i=0; i<nodes.length; i++) {
                nodes[i].highlight(CONFIG.colors.nodeHighlight);
                
                await new Promise(r => setTimeout(r, 500));

                if(nodes[i].value === val) {
                    log(`Found ${val} at index ${i}!`);
                    nodes[i].highlight(CONFIG.colors.nodeFound);
                    found = true;
                    setTimeout(() => nodes[i]?.resetColor(), 2000);
                    break;
                } else {
                    nodes[i].resetColor();
                }
            }

            if(!found) log(`${val} not found in list.`);
            isAnimating = false;
        }

        async function handleReverse() {
            if(isAnimating || nodes.length <= 1) return;
            isAnimating = true;
            log("Reversing list...");

            nodes.forEach(n => n.highlight(0xffff00));
            await new Promise(r => setTimeout(r, 500));
            nodes.forEach(n => n.resetColor());

            nodes.reverse();
            renderList();
            log("List reversed!");
            
            await new Promise(r => setTimeout(r, 1000));
            isAnimating = false;
        }
        
        // --- Gemini AI Logic ---

        async function callGemini(text) {
            const resultBox = document.getElementById('ai-explanation');
            resultBox.style.display = 'block';
            resultBox.innerHTML = '<div class="spinner"></div> Thinking...';

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: text }] }] })
                });

                if(!response.ok) throw new Error('API Error');
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (e) {
                resultBox.innerHTML = "Error connecting to AI.";
                console.error(e);
                return null;
            }
        }

        async function handleAutoSimulate() {
            if(isAnimating) return;
            const input = document.getElementById('ai-prompt').value;
            if(!input) return;
            
            // Construct instruction to parse NL to JSON
            const prompt = `
                You are a DSA simulation assistant. Translate the following user request into a JSON array of commands.
                Supported commands:
                - {"op": "insert", "loc": "head"|"tail"|"index", "val": number, "idx": number (only for index loc)}
                - {"op": "delete", "loc": "head"|"tail"|"index", "idx": number}
                - {"op": "search", "val": number}
                - {"op": "reverse"}
                
                Current Mode: ${currentMode}.
                User Request: "${input}".
                
                Return ONLY the JSON array. No markdown.
            `;
            
            const jsonStr = await callGemini(prompt);
            if(!jsonStr) return;

            // Remove markdown code blocks if present
            const cleanJson = jsonStr.replace(/```json|```/g, '').trim();
            
            try {
                const commands = JSON.parse(cleanJson);
                const expl = document.getElementById('ai-explanation');
                expl.innerHTML = `Running ${commands.length} operations...`;
                
                // Execute sequentially
                for(let cmd of commands) {
                    if(cmd.op === 'insert') {
                        await handleInsert(cmd.loc, cmd.val, cmd.idx);
                    } else if (cmd.op === 'delete') {
                        await handleDelete(cmd.loc, cmd.idx);
                    } else if (cmd.op === 'search') {
                        await handleSearch(cmd.val);
                    } else if (cmd.op === 'reverse') {
                        await handleReverse();
                    }
                    // Small pause between ops
                    await new Promise(r => setTimeout(r, 500));
                }
                expl.innerHTML = "Simulation complete.";
            } catch(e) {
                document.getElementById('ai-explanation').innerHTML = "Could not parse AI commands.";
            }
        }

        async function handleExplainState() {
            if(nodes.length === 0) {
                 document.getElementById('ai-explanation').innerText = "The list is empty. Nothing to explain.";
                 document.getElementById('ai-explanation').style.display = 'block';
                 return;
            }

            const prompt = `
                Analyze this ${currentMode} Linked List.
                Nodes: [${nodes.map(n => n.value).join(' -> ')}].
                
                Explain the current state of this data structure simply to a student. Mention the Head, Tail, and how the pointers are connecting the data.
                Keep it brief (max 3 sentences).
            `;
            
            const explanation = await callGemini(prompt);
            if(explanation) {
                document.getElementById('ai-explanation').innerText = explanation;
            }
        }

        // --- Init & Loop ---
        [10, 20, 30, 40].forEach(v => nodes.push(new ListNode(v)));
        renderList();

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Subtle rotation for CUBES (removed floating y-position)
            nodes.forEach((node, i) => {
                if(node.mesh) {
                    // Subtle rotation makes cubes look better and alive without floating
                    node.mesh.rotation.y = Math.sin(time * 0.0005 + i) * 0.1;
                    node.mesh.rotation.z = Math.cos(time * 0.0005 + i) * 0.05;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
